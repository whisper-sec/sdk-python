# coding: utf-8

"""
    Whisper Security API

    # Whisper Security Threat Intelligence API  The Whisper Security API provides comprehensive threat intelligence, geolocation data, and security operations capabilities for enterprise security teams and developers.  ## Key Capabilities  - **Indicator Enrichment**: Get comprehensive intelligence on IP addresses and domains including   geolocation, WHOIS, DNS, reputation scoring, and relationship mapping. - **Geolocation Services**: Fast IP-to-location lookups with ISP, ASN, and network information. - **Security Operations**: Asynchronous tools for bulk enrichment, infrastructure scanning,   AI-powered threat investigation, and monitoring.  ## API Design  - **RESTful**: Standard HTTP methods (GET, POST, PUT, DELETE) with JSON request/response bodies. - **Synchronous Endpoints**: Fast responses (<500ms) for indicator enrichment and geolocation. - **Asynchronous Jobs**: Long-running operations return a job ID for polling results. - **Consistent Error Handling**: Standardized error responses with status codes, error codes, and messages.  ## Authentication  All API endpoints require Bearer token authentication. Include your API key in the `Authorization` header: `Authorization: Bearer <your-api-key>`  ## Rate Limits  Rate limits are applied per-user and vary by endpoint category:  | Endpoint Category | Rate Limit | Description | |-------------------|------------|-------------| | Indicators (`/v1/indicators/*`) | 100 req/sec | Single indicator enrichment | | Location (`/v1/location/*`) | 100 req/sec | Geolocation lookups | | Jobs (`/v1/ops/jobs/*`) | 100 req/sec | Job status and listing | | Bulk Operations (`/v1/ops/enrichment/bulk`) | 10 req/sec | Bulk indicator processing | | Screenshots (`/v1/ops/screenshots/*`) | 10 req/sec | Screenshot capture and scheduling | | Scans (`/v1/ops/scans/*`) | 10 req/sec | Infrastructure scanning | | Monitoring (`/v1/ops/monitoring/*`) | 10 req/sec | Uptime monitoring | | Tracking (`/v1/ops/tracking/*`) | 10 req/sec | Change tracking | | AI Investigate (`/v1/ops/ai/investigate`) | 5 req/min | Deep threat investigation | | AI Correlate (`/v1/ops/ai/correlate`) | 5 req/min | Global correlation | | AI Attribute (`/v1/ops/ai/attribute`) | 5 req/min | Threat actor attribution | | AI Pivot (`/v1/ops/ai/pivot`) | 5 req/min | Infrastructure pivoting |  When rate limits are exceeded, the API returns HTTP `429 Too Many Requests` with a `Retry-After` header indicating when you can retry. The response body includes: ```json {   \"error\": \"Too Many Requests\",   \"message\": \"Rate limit exceeded for <category>. Please retry after N seconds.\",   \"retryAfter\": N } ```  ## Response Conventions  - All timestamps are in ISO 8601 format (UTC). - Pagination uses `limit` and `offset` parameters. - Field names use camelCase throughout the API.  ## Official SDKs  - **Python**: [github.com/whisper-sec/sdk-python](https://github.com/whisper-sec/sdk-python) - **TypeScript/JavaScript**: [github.com/whisper-sec/sdk-typescript](https://github.com/whisper-sec/sdk-typescript) - **Java**: [github.com/whisper-sec/sdk-java](https://github.com/whisper-sec/sdk-java) - **C#/.NET**: [github.com/whisper-sec/sdk-csharp](https://github.com/whisper-sec/sdk-csharp)  ## Resources  - **Website**: [whisper.security](https://whisper.security) - **Dashboard**: [dash.whisper.security](https://dash.whisper.security) - Manage API keys and view usage - **Documentation**: [docs.whisper.security](https://docs.whisper.security) - Guides and tutorials 

    The version of the OpenAPI document: 1.0.0
    Contact: support@whisper.security
    Generated by OpenAPI Generator (https://openapi-generator.tech)

    Do not edit the class manually.
"""  # noqa: E501

import warnings
from pydantic import validate_call, Field, StrictFloat, StrictStr, StrictInt
from typing import Any, Dict, List, Optional, Tuple, Union
from typing_extensions import Annotated

from pydantic import Field, StrictInt, StrictStr, field_validator
from typing import Optional
from typing_extensions import Annotated
from whisper_api_sdk.models.bulk_enrichment_result import BulkEnrichmentResult
from whisper_api_sdk.models.bulk_request import BulkRequest
from whisper_api_sdk.models.graph_response import GraphResponse
from whisper_api_sdk.models.history_response import HistoryResponse
from whisper_api_sdk.models.indicator_response import IndicatorResponse
from whisper_api_sdk.models.predictive_risk_response import PredictiveRiskResponse
from whisper_api_sdk.models.search_request import SearchRequest
from whisper_api_sdk.models.search_response import SearchResponse
from whisper_api_sdk.models.similar_domains_ops_request import SimilarDomainsOpsRequest
from whisper_api_sdk.models.similar_domains_response import SimilarDomainsResponse
from whisper_api_sdk.models.subdomain_response import SubdomainResponse

from whisper_api_sdk.api_client import ApiClient, RequestSerialized
from whisper_api_sdk.api_response import ApiResponse
from whisper_api_sdk.rest import RESTResponseType


class EnrichmentApi:
    """NOTE: This class is auto generated by OpenAPI Generator
    Ref: https://openapi-generator.tech

    Do not edit the class manually.
    """

    def __init__(self, api_client=None) -> None:
        if api_client is None:
            api_client = ApiClient.get_default()
        self.api_client = api_client


    @validate_call
    def bulk_enrichment(
        self,
        bulk_request: Annotated[BulkRequest, Field(description="List of indicators and processing options.")],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> BulkEnrichmentResult:
        """Bulk Indicator Enrichment (Asynchronous)

        <p>Process multiple indicators (IPs and/or domains) in a single request. This endpoint is optimized for batch processing and can handle up to 100 indicators per request.</p>  <h4>Performance</h4> <p>Processing time depends on batch size and indicator types. IP enrichment is faster than domain enrichment.</p> <ul>     <li><b>IPs only:</b> 2-10 seconds for typical batches</li>     <li><b>Domains only:</b> 10-30 seconds (WHOIS lookups are slower)</li>     <li><b>Mixed:</b> 5-30 seconds depending on ratio</li> </ul>  <h4>Rate Limits</h4> <p>Limited to 10 requests per minute due to the resource-intensive nature of bulk operations.</p>  <h4>Response Structure</h4> <p>When the job completes, the <code>result</code> field contains:</p> <ul>     <li><code>status</code>: \"completed\" or \"failed\"</li>     <li><code>results</code>: Array of enriched indicator objects (see below)</li>     <li><code>errors</code>: Array of failed enrichments with error details</li>     <li><code>totalProcessed</code>: Number of indicators processed</li>     <li><code>totalFailed</code>: Number of failed enrichments</li>     <li><code>totalIndicators</code>: Total indicators in request</li>     <li><code>successRate</code>: Percentage of successful enrichments (0-100)</li> </ul>  <h4>Result Item Structure</h4> <p>Each item in the <code>results</code> array includes:</p> <ul>     <li><code>indicator</code>: The original indicator value</li>     <li><code>type</code>: \"ip\" or \"domain\"</li>     <li><code>query</code>: Request metadata (type, value, timestamp, response_time_ms)</li>     <li><code>summary</code>: Key information summary</li> </ul>  <p><b>For IP indicators:</b></p> <ul>     <li><code>geolocation</code>: Country, city, coordinates, ISP, ASN</li>     <li><code>network</code>: BGP routing data, prefix visibility, origins</li>     <li><code>isp</code>: ISP name, organization, ASN</li>     <li><code>reputation</code>: Risk score, blacklist scores</li>     <li><code>relationships</code>: Related domains, shared infrastructure</li> </ul>  <p><b>For domain indicators:</b></p> <ul>     <li><code>registration</code>: WHOIS data (registrar, dates, nameservers, status)</li>     <li><code>dns</code>: DNS records (A, AAAA, MX, NS, TXT, CNAME)</li>     <li><code>reputation</code>: Domain reputation, infrastructure scores</li>     <li><code>relationships</code>: Related domains, incoming/outgoing links</li> </ul>  <h4>Error Item Structure</h4> <p>Each item in the <code>errors</code> array includes:</p> <ul>     <li><code>indicator</code>: The indicator that failed</li>     <li><code>type</code>: \"ip\" or \"domain\"</li>     <li><code>error</code>: true</li>     <li><code>message</code>: Error description</li> </ul> 

        :param bulk_request: List of indicators and processing options. (required)
        :type bulk_request: BulkRequest
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._bulk_enrichment_serialize(
            bulk_request=bulk_request,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '202': "JobResponse",
            '200': "BulkEnrichmentResult",
            '400': "ErrorResponse",
            '401': "ErrorResponse",
            '429': "ErrorResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def bulk_enrichment_with_http_info(
        self,
        bulk_request: Annotated[BulkRequest, Field(description="List of indicators and processing options.")],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[BulkEnrichmentResult]:
        """Bulk Indicator Enrichment (Asynchronous)

        <p>Process multiple indicators (IPs and/or domains) in a single request. This endpoint is optimized for batch processing and can handle up to 100 indicators per request.</p>  <h4>Performance</h4> <p>Processing time depends on batch size and indicator types. IP enrichment is faster than domain enrichment.</p> <ul>     <li><b>IPs only:</b> 2-10 seconds for typical batches</li>     <li><b>Domains only:</b> 10-30 seconds (WHOIS lookups are slower)</li>     <li><b>Mixed:</b> 5-30 seconds depending on ratio</li> </ul>  <h4>Rate Limits</h4> <p>Limited to 10 requests per minute due to the resource-intensive nature of bulk operations.</p>  <h4>Response Structure</h4> <p>When the job completes, the <code>result</code> field contains:</p> <ul>     <li><code>status</code>: \"completed\" or \"failed\"</li>     <li><code>results</code>: Array of enriched indicator objects (see below)</li>     <li><code>errors</code>: Array of failed enrichments with error details</li>     <li><code>totalProcessed</code>: Number of indicators processed</li>     <li><code>totalFailed</code>: Number of failed enrichments</li>     <li><code>totalIndicators</code>: Total indicators in request</li>     <li><code>successRate</code>: Percentage of successful enrichments (0-100)</li> </ul>  <h4>Result Item Structure</h4> <p>Each item in the <code>results</code> array includes:</p> <ul>     <li><code>indicator</code>: The original indicator value</li>     <li><code>type</code>: \"ip\" or \"domain\"</li>     <li><code>query</code>: Request metadata (type, value, timestamp, response_time_ms)</li>     <li><code>summary</code>: Key information summary</li> </ul>  <p><b>For IP indicators:</b></p> <ul>     <li><code>geolocation</code>: Country, city, coordinates, ISP, ASN</li>     <li><code>network</code>: BGP routing data, prefix visibility, origins</li>     <li><code>isp</code>: ISP name, organization, ASN</li>     <li><code>reputation</code>: Risk score, blacklist scores</li>     <li><code>relationships</code>: Related domains, shared infrastructure</li> </ul>  <p><b>For domain indicators:</b></p> <ul>     <li><code>registration</code>: WHOIS data (registrar, dates, nameservers, status)</li>     <li><code>dns</code>: DNS records (A, AAAA, MX, NS, TXT, CNAME)</li>     <li><code>reputation</code>: Domain reputation, infrastructure scores</li>     <li><code>relationships</code>: Related domains, incoming/outgoing links</li> </ul>  <h4>Error Item Structure</h4> <p>Each item in the <code>errors</code> array includes:</p> <ul>     <li><code>indicator</code>: The indicator that failed</li>     <li><code>type</code>: \"ip\" or \"domain\"</li>     <li><code>error</code>: true</li>     <li><code>message</code>: Error description</li> </ul> 

        :param bulk_request: List of indicators and processing options. (required)
        :type bulk_request: BulkRequest
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._bulk_enrichment_serialize(
            bulk_request=bulk_request,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '202': "JobResponse",
            '200': "BulkEnrichmentResult",
            '400': "ErrorResponse",
            '401': "ErrorResponse",
            '429': "ErrorResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def bulk_enrichment_without_preload_content(
        self,
        bulk_request: Annotated[BulkRequest, Field(description="List of indicators and processing options.")],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """Bulk Indicator Enrichment (Asynchronous)

        <p>Process multiple indicators (IPs and/or domains) in a single request. This endpoint is optimized for batch processing and can handle up to 100 indicators per request.</p>  <h4>Performance</h4> <p>Processing time depends on batch size and indicator types. IP enrichment is faster than domain enrichment.</p> <ul>     <li><b>IPs only:</b> 2-10 seconds for typical batches</li>     <li><b>Domains only:</b> 10-30 seconds (WHOIS lookups are slower)</li>     <li><b>Mixed:</b> 5-30 seconds depending on ratio</li> </ul>  <h4>Rate Limits</h4> <p>Limited to 10 requests per minute due to the resource-intensive nature of bulk operations.</p>  <h4>Response Structure</h4> <p>When the job completes, the <code>result</code> field contains:</p> <ul>     <li><code>status</code>: \"completed\" or \"failed\"</li>     <li><code>results</code>: Array of enriched indicator objects (see below)</li>     <li><code>errors</code>: Array of failed enrichments with error details</li>     <li><code>totalProcessed</code>: Number of indicators processed</li>     <li><code>totalFailed</code>: Number of failed enrichments</li>     <li><code>totalIndicators</code>: Total indicators in request</li>     <li><code>successRate</code>: Percentage of successful enrichments (0-100)</li> </ul>  <h4>Result Item Structure</h4> <p>Each item in the <code>results</code> array includes:</p> <ul>     <li><code>indicator</code>: The original indicator value</li>     <li><code>type</code>: \"ip\" or \"domain\"</li>     <li><code>query</code>: Request metadata (type, value, timestamp, response_time_ms)</li>     <li><code>summary</code>: Key information summary</li> </ul>  <p><b>For IP indicators:</b></p> <ul>     <li><code>geolocation</code>: Country, city, coordinates, ISP, ASN</li>     <li><code>network</code>: BGP routing data, prefix visibility, origins</li>     <li><code>isp</code>: ISP name, organization, ASN</li>     <li><code>reputation</code>: Risk score, blacklist scores</li>     <li><code>relationships</code>: Related domains, shared infrastructure</li> </ul>  <p><b>For domain indicators:</b></p> <ul>     <li><code>registration</code>: WHOIS data (registrar, dates, nameservers, status)</li>     <li><code>dns</code>: DNS records (A, AAAA, MX, NS, TXT, CNAME)</li>     <li><code>reputation</code>: Domain reputation, infrastructure scores</li>     <li><code>relationships</code>: Related domains, incoming/outgoing links</li> </ul>  <h4>Error Item Structure</h4> <p>Each item in the <code>errors</code> array includes:</p> <ul>     <li><code>indicator</code>: The indicator that failed</li>     <li><code>type</code>: \"ip\" or \"domain\"</li>     <li><code>error</code>: true</li>     <li><code>message</code>: Error description</li> </ul> 

        :param bulk_request: List of indicators and processing options. (required)
        :type bulk_request: BulkRequest
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._bulk_enrichment_serialize(
            bulk_request=bulk_request,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '202': "JobResponse",
            '200': "BulkEnrichmentResult",
            '400': "ErrorResponse",
            '401': "ErrorResponse",
            '429': "ErrorResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _bulk_enrichment_serialize(
        self,
        bulk_request,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        # process the query parameters
        # process the header parameters
        # process the form parameters
        # process the body parameter
        if bulk_request is not None:
            _body_params = bulk_request


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )

        # set the HTTP header `Content-Type`
        if _content_type:
            _header_params['Content-Type'] = _content_type
        else:
            _default_content_type = (
                self.api_client.select_header_content_type(
                    [
                        'application/json'
                    ]
                )
            )
            if _default_content_type is not None:
                _header_params['Content-Type'] = _default_content_type

        # authentication setting
        _auth_settings: List[str] = [
            'bearerAuth'
        ]

        return self.api_client.param_serialize(
            method='POST',
            resource_path='/v1/ops/enrichment/bulk',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def get_indicator(
        self,
        type: Annotated[StrictStr, Field(description="The type of indicator to enrich.")],
        value: Annotated[StrictStr, Field(description="The value of the indicator (e.g., an IPv4/IPv6 address or a domain name).")],
        include: Annotated[Optional[StrictStr], Field(description="A comma-separated list of additional data modules to include in the response. Note: WHOIS and DNS data are included by default for domains. Requesting more modules may increase latency.")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> IndicatorResponse:
        """Enrich a Single Indicator (IP or Domain)

        <p>Retrieves comprehensive intelligence for a single IP address or domain. This is the primary, high-performance endpoint for synchronous enrichment.</p> <p>It aggregates data from multiple sources, including geolocation, WHOIS, DNS, reputation scoring, and relationship mapping. Use the `include` parameter to request additional, deeper data sets that may have higher latency.</p> <h4>Performance:</h4> <ul>     <li><b>Base Response:</b> Typically under 500ms.</li>     <li><b>With `include=routing`:</b> First request may take up to 5 seconds; subsequent requests are cached for 5 minutes and respond in &lt;200ms.</li>     <li><b>With `include=ip_intelligence`:</b> Adds 200-500ms of latency for each IP address resolved from the domain.</li> </ul> 

        :param type: The type of indicator to enrich. (required)
        :type type: str
        :param value: The value of the indicator (e.g., an IPv4/IPv6 address or a domain name). (required)
        :type value: str
        :param include: A comma-separated list of additional data modules to include in the response. Note: WHOIS and DNS data are included by default for domains. Requesting more modules may increase latency.
        :type include: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._get_indicator_serialize(
            type=type,
            value=value,
            include=include,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "IndicatorResponse",
            '400': "ErrorResponse",
            '401': "ErrorResponse",
            '404': "ErrorResponse",
            '429': "ErrorResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def get_indicator_with_http_info(
        self,
        type: Annotated[StrictStr, Field(description="The type of indicator to enrich.")],
        value: Annotated[StrictStr, Field(description="The value of the indicator (e.g., an IPv4/IPv6 address or a domain name).")],
        include: Annotated[Optional[StrictStr], Field(description="A comma-separated list of additional data modules to include in the response. Note: WHOIS and DNS data are included by default for domains. Requesting more modules may increase latency.")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[IndicatorResponse]:
        """Enrich a Single Indicator (IP or Domain)

        <p>Retrieves comprehensive intelligence for a single IP address or domain. This is the primary, high-performance endpoint for synchronous enrichment.</p> <p>It aggregates data from multiple sources, including geolocation, WHOIS, DNS, reputation scoring, and relationship mapping. Use the `include` parameter to request additional, deeper data sets that may have higher latency.</p> <h4>Performance:</h4> <ul>     <li><b>Base Response:</b> Typically under 500ms.</li>     <li><b>With `include=routing`:</b> First request may take up to 5 seconds; subsequent requests are cached for 5 minutes and respond in &lt;200ms.</li>     <li><b>With `include=ip_intelligence`:</b> Adds 200-500ms of latency for each IP address resolved from the domain.</li> </ul> 

        :param type: The type of indicator to enrich. (required)
        :type type: str
        :param value: The value of the indicator (e.g., an IPv4/IPv6 address or a domain name). (required)
        :type value: str
        :param include: A comma-separated list of additional data modules to include in the response. Note: WHOIS and DNS data are included by default for domains. Requesting more modules may increase latency.
        :type include: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._get_indicator_serialize(
            type=type,
            value=value,
            include=include,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "IndicatorResponse",
            '400': "ErrorResponse",
            '401': "ErrorResponse",
            '404': "ErrorResponse",
            '429': "ErrorResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def get_indicator_without_preload_content(
        self,
        type: Annotated[StrictStr, Field(description="The type of indicator to enrich.")],
        value: Annotated[StrictStr, Field(description="The value of the indicator (e.g., an IPv4/IPv6 address or a domain name).")],
        include: Annotated[Optional[StrictStr], Field(description="A comma-separated list of additional data modules to include in the response. Note: WHOIS and DNS data are included by default for domains. Requesting more modules may increase latency.")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """Enrich a Single Indicator (IP or Domain)

        <p>Retrieves comprehensive intelligence for a single IP address or domain. This is the primary, high-performance endpoint for synchronous enrichment.</p> <p>It aggregates data from multiple sources, including geolocation, WHOIS, DNS, reputation scoring, and relationship mapping. Use the `include` parameter to request additional, deeper data sets that may have higher latency.</p> <h4>Performance:</h4> <ul>     <li><b>Base Response:</b> Typically under 500ms.</li>     <li><b>With `include=routing`:</b> First request may take up to 5 seconds; subsequent requests are cached for 5 minutes and respond in &lt;200ms.</li>     <li><b>With `include=ip_intelligence`:</b> Adds 200-500ms of latency for each IP address resolved from the domain.</li> </ul> 

        :param type: The type of indicator to enrich. (required)
        :type type: str
        :param value: The value of the indicator (e.g., an IPv4/IPv6 address or a domain name). (required)
        :type value: str
        :param include: A comma-separated list of additional data modules to include in the response. Note: WHOIS and DNS data are included by default for domains. Requesting more modules may increase latency.
        :type include: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._get_indicator_serialize(
            type=type,
            value=value,
            include=include,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "IndicatorResponse",
            '400': "ErrorResponse",
            '401': "ErrorResponse",
            '404': "ErrorResponse",
            '429': "ErrorResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _get_indicator_serialize(
        self,
        type,
        value,
        include,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        if type is not None:
            _path_params['type'] = type
        if value is not None:
            _path_params['value'] = value
        # process the query parameters
        if include is not None:
            
            _query_params.append(('include', include))
            
        # process the header parameters
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )


        # authentication setting
        _auth_settings: List[str] = [
            'bearerAuth'
        ]

        return self.api_client.param_serialize(
            method='GET',
            resource_path='/v1/indicators/{type}/{value}',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def get_indicator_graph(
        self,
        type: Annotated[StrictStr, Field(description="Type of indicator")],
        value: Annotated[StrictStr, Field(description="The indicator value (IP address or domain)")],
        limit: Annotated[Optional[StrictInt], Field(description="Maximum number of nodes to return in the graph")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> GraphResponse:
        """Get Infrastructure Relationship Graph

        <p>Returns graph visualization data showing relationships between the indicator and related infrastructure. Perfect for interactive network diagrams and threat actor infrastructure mapping.</p> <h4>Relationship Types Included:</h4> <ul>     <li><b>For Domains:</b>         <ul>             <li>Resolves to IPs</li>             <li>Shares nameservers with</li>             <li>Same SSL certificate as</li>             <li>Same registrant as</li>             <li>Links to/from other domains</li>         </ul>     </li>     <li><b>For IPs:</b>         <ul>             <li>Hosts domains</li>             <li>Same ASN as</li>             <li>Same network block as</li>             <li>Connected via routing</li>         </ul>     </li> </ul> <h4>Output Format:</h4> <p>Compatible with react-force-graph, vis.js, cytoscape.js:</p> <pre><code>{   \"nodes\": [     {\"id\": \"example.com\", \"type\": \"domain\", \"label\": \"example.com\"},     {\"id\": \"8.8.8.8\", \"type\": \"ip\", \"label\": \"8.8.8.8\"}   ],   \"links\": [     {\"source\": \"example.com\", \"target\": \"8.8.8.8\", \"type\": \"resolves_to\"}   ] }</code></pre> <h4>Performance:</h4> <ul>     <li>Response Time: 500ms-2s depending on graph complexity</li>     <li>Default: 100 nodes maximum (adjustable)</li> </ul> <h4>Use Cases:</h4> <ul>     <li>Interactive threat actor infrastructure visualization</li>     <li>Discovering related phishing campaigns</li>     <li>Mapping shadow IT and sprawl</li>     <li>Network topology visualization</li> </ul> 

        :param type: Type of indicator (required)
        :type type: str
        :param value: The indicator value (IP address or domain) (required)
        :type value: str
        :param limit: Maximum number of nodes to return in the graph
        :type limit: int
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._get_indicator_graph_serialize(
            type=type,
            value=value,
            limit=limit,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "GraphResponse",
            '400': "ErrorResponse",
            '401': "ErrorResponse",
            '404': "ErrorResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def get_indicator_graph_with_http_info(
        self,
        type: Annotated[StrictStr, Field(description="Type of indicator")],
        value: Annotated[StrictStr, Field(description="The indicator value (IP address or domain)")],
        limit: Annotated[Optional[StrictInt], Field(description="Maximum number of nodes to return in the graph")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[GraphResponse]:
        """Get Infrastructure Relationship Graph

        <p>Returns graph visualization data showing relationships between the indicator and related infrastructure. Perfect for interactive network diagrams and threat actor infrastructure mapping.</p> <h4>Relationship Types Included:</h4> <ul>     <li><b>For Domains:</b>         <ul>             <li>Resolves to IPs</li>             <li>Shares nameservers with</li>             <li>Same SSL certificate as</li>             <li>Same registrant as</li>             <li>Links to/from other domains</li>         </ul>     </li>     <li><b>For IPs:</b>         <ul>             <li>Hosts domains</li>             <li>Same ASN as</li>             <li>Same network block as</li>             <li>Connected via routing</li>         </ul>     </li> </ul> <h4>Output Format:</h4> <p>Compatible with react-force-graph, vis.js, cytoscape.js:</p> <pre><code>{   \"nodes\": [     {\"id\": \"example.com\", \"type\": \"domain\", \"label\": \"example.com\"},     {\"id\": \"8.8.8.8\", \"type\": \"ip\", \"label\": \"8.8.8.8\"}   ],   \"links\": [     {\"source\": \"example.com\", \"target\": \"8.8.8.8\", \"type\": \"resolves_to\"}   ] }</code></pre> <h4>Performance:</h4> <ul>     <li>Response Time: 500ms-2s depending on graph complexity</li>     <li>Default: 100 nodes maximum (adjustable)</li> </ul> <h4>Use Cases:</h4> <ul>     <li>Interactive threat actor infrastructure visualization</li>     <li>Discovering related phishing campaigns</li>     <li>Mapping shadow IT and sprawl</li>     <li>Network topology visualization</li> </ul> 

        :param type: Type of indicator (required)
        :type type: str
        :param value: The indicator value (IP address or domain) (required)
        :type value: str
        :param limit: Maximum number of nodes to return in the graph
        :type limit: int
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._get_indicator_graph_serialize(
            type=type,
            value=value,
            limit=limit,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "GraphResponse",
            '400': "ErrorResponse",
            '401': "ErrorResponse",
            '404': "ErrorResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def get_indicator_graph_without_preload_content(
        self,
        type: Annotated[StrictStr, Field(description="Type of indicator")],
        value: Annotated[StrictStr, Field(description="The indicator value (IP address or domain)")],
        limit: Annotated[Optional[StrictInt], Field(description="Maximum number of nodes to return in the graph")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """Get Infrastructure Relationship Graph

        <p>Returns graph visualization data showing relationships between the indicator and related infrastructure. Perfect for interactive network diagrams and threat actor infrastructure mapping.</p> <h4>Relationship Types Included:</h4> <ul>     <li><b>For Domains:</b>         <ul>             <li>Resolves to IPs</li>             <li>Shares nameservers with</li>             <li>Same SSL certificate as</li>             <li>Same registrant as</li>             <li>Links to/from other domains</li>         </ul>     </li>     <li><b>For IPs:</b>         <ul>             <li>Hosts domains</li>             <li>Same ASN as</li>             <li>Same network block as</li>             <li>Connected via routing</li>         </ul>     </li> </ul> <h4>Output Format:</h4> <p>Compatible with react-force-graph, vis.js, cytoscape.js:</p> <pre><code>{   \"nodes\": [     {\"id\": \"example.com\", \"type\": \"domain\", \"label\": \"example.com\"},     {\"id\": \"8.8.8.8\", \"type\": \"ip\", \"label\": \"8.8.8.8\"}   ],   \"links\": [     {\"source\": \"example.com\", \"target\": \"8.8.8.8\", \"type\": \"resolves_to\"}   ] }</code></pre> <h4>Performance:</h4> <ul>     <li>Response Time: 500ms-2s depending on graph complexity</li>     <li>Default: 100 nodes maximum (adjustable)</li> </ul> <h4>Use Cases:</h4> <ul>     <li>Interactive threat actor infrastructure visualization</li>     <li>Discovering related phishing campaigns</li>     <li>Mapping shadow IT and sprawl</li>     <li>Network topology visualization</li> </ul> 

        :param type: Type of indicator (required)
        :type type: str
        :param value: The indicator value (IP address or domain) (required)
        :type value: str
        :param limit: Maximum number of nodes to return in the graph
        :type limit: int
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._get_indicator_graph_serialize(
            type=type,
            value=value,
            limit=limit,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "GraphResponse",
            '400': "ErrorResponse",
            '401': "ErrorResponse",
            '404': "ErrorResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _get_indicator_graph_serialize(
        self,
        type,
        value,
        limit,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        if type is not None:
            _path_params['type'] = type
        if value is not None:
            _path_params['value'] = value
        # process the query parameters
        if limit is not None:
            
            _query_params.append(('limit', limit))
            
        # process the header parameters
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )


        # authentication setting
        _auth_settings: List[str] = [
            'bearerAuth'
        ]

        return self.api_client.param_serialize(
            method='GET',
            resource_path='/v1/indicators/{type}/{value}/graph',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def get_indicator_history(
        self,
        type: Annotated[StrictStr, Field(description="Type of indicator")],
        value: Annotated[StrictStr, Field(description="The indicator value (IP address or domain)")],
        history_type: Annotated[Optional[StrictStr], Field(description="Type of historical data to retrieve")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> HistoryResponse:
        """Get Historical Data for Indicator

        <p>Retrieves time-series historical data for an IP address or domain. Track how infrastructure changes over time for threat intelligence and forensic analysis.</p> <h4>History Types:</h4> <ul>     <li><b>whois:</b> Registration history - registrant changes, expiration updates, transfers</li>     <li><b>routing:</b> BGP routing history - prefix announcements, ASN changes, route hijacks</li>     <li><b>dns:</b> DNS resolution history - IP address changes, nameserver updates</li>     <li><b>ssl:</b> Certificate history - cert replacements, CA changes, expiration events</li>     <li><b>reputation:</b> Risk score history - blacklist appearances, reputation changes</li> </ul> <h4>Data Format:</h4> <p>Timeline with dated snapshots showing what changed and when:</p> <pre><code>{   \"history\": [     {       \"timestamp\": \"2025-01-15T10:00:00Z\",       \"field\": \"registrant_company\",       \"old_value\": \"Evil Corp\",       \"new_value\": \"Legitimate LLC\"     }   ] }</code></pre> <h4>Use Cases:</h4> <ul>     <li>Tracking domain ownership changes</li>     <li>Investigating IP reputation degradation</li>     <li>Forensic timeline reconstruction</li>     <li>Detecting infrastructure pivots by threat actors</li> </ul> 

        :param type: Type of indicator (required)
        :type type: str
        :param value: The indicator value (IP address or domain) (required)
        :type value: str
        :param history_type: Type of historical data to retrieve
        :type history_type: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._get_indicator_history_serialize(
            type=type,
            value=value,
            history_type=history_type,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "HistoryResponse",
            '400': "ErrorResponse",
            '401': "ErrorResponse",
            '404': "ErrorResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def get_indicator_history_with_http_info(
        self,
        type: Annotated[StrictStr, Field(description="Type of indicator")],
        value: Annotated[StrictStr, Field(description="The indicator value (IP address or domain)")],
        history_type: Annotated[Optional[StrictStr], Field(description="Type of historical data to retrieve")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[HistoryResponse]:
        """Get Historical Data for Indicator

        <p>Retrieves time-series historical data for an IP address or domain. Track how infrastructure changes over time for threat intelligence and forensic analysis.</p> <h4>History Types:</h4> <ul>     <li><b>whois:</b> Registration history - registrant changes, expiration updates, transfers</li>     <li><b>routing:</b> BGP routing history - prefix announcements, ASN changes, route hijacks</li>     <li><b>dns:</b> DNS resolution history - IP address changes, nameserver updates</li>     <li><b>ssl:</b> Certificate history - cert replacements, CA changes, expiration events</li>     <li><b>reputation:</b> Risk score history - blacklist appearances, reputation changes</li> </ul> <h4>Data Format:</h4> <p>Timeline with dated snapshots showing what changed and when:</p> <pre><code>{   \"history\": [     {       \"timestamp\": \"2025-01-15T10:00:00Z\",       \"field\": \"registrant_company\",       \"old_value\": \"Evil Corp\",       \"new_value\": \"Legitimate LLC\"     }   ] }</code></pre> <h4>Use Cases:</h4> <ul>     <li>Tracking domain ownership changes</li>     <li>Investigating IP reputation degradation</li>     <li>Forensic timeline reconstruction</li>     <li>Detecting infrastructure pivots by threat actors</li> </ul> 

        :param type: Type of indicator (required)
        :type type: str
        :param value: The indicator value (IP address or domain) (required)
        :type value: str
        :param history_type: Type of historical data to retrieve
        :type history_type: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._get_indicator_history_serialize(
            type=type,
            value=value,
            history_type=history_type,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "HistoryResponse",
            '400': "ErrorResponse",
            '401': "ErrorResponse",
            '404': "ErrorResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def get_indicator_history_without_preload_content(
        self,
        type: Annotated[StrictStr, Field(description="Type of indicator")],
        value: Annotated[StrictStr, Field(description="The indicator value (IP address or domain)")],
        history_type: Annotated[Optional[StrictStr], Field(description="Type of historical data to retrieve")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """Get Historical Data for Indicator

        <p>Retrieves time-series historical data for an IP address or domain. Track how infrastructure changes over time for threat intelligence and forensic analysis.</p> <h4>History Types:</h4> <ul>     <li><b>whois:</b> Registration history - registrant changes, expiration updates, transfers</li>     <li><b>routing:</b> BGP routing history - prefix announcements, ASN changes, route hijacks</li>     <li><b>dns:</b> DNS resolution history - IP address changes, nameserver updates</li>     <li><b>ssl:</b> Certificate history - cert replacements, CA changes, expiration events</li>     <li><b>reputation:</b> Risk score history - blacklist appearances, reputation changes</li> </ul> <h4>Data Format:</h4> <p>Timeline with dated snapshots showing what changed and when:</p> <pre><code>{   \"history\": [     {       \"timestamp\": \"2025-01-15T10:00:00Z\",       \"field\": \"registrant_company\",       \"old_value\": \"Evil Corp\",       \"new_value\": \"Legitimate LLC\"     }   ] }</code></pre> <h4>Use Cases:</h4> <ul>     <li>Tracking domain ownership changes</li>     <li>Investigating IP reputation degradation</li>     <li>Forensic timeline reconstruction</li>     <li>Detecting infrastructure pivots by threat actors</li> </ul> 

        :param type: Type of indicator (required)
        :type type: str
        :param value: The indicator value (IP address or domain) (required)
        :type value: str
        :param history_type: Type of historical data to retrieve
        :type history_type: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._get_indicator_history_serialize(
            type=type,
            value=value,
            history_type=history_type,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "HistoryResponse",
            '400': "ErrorResponse",
            '401': "ErrorResponse",
            '404': "ErrorResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _get_indicator_history_serialize(
        self,
        type,
        value,
        history_type,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        if type is not None:
            _path_params['type'] = type
        if value is not None:
            _path_params['value'] = value
        # process the query parameters
        if history_type is not None:
            
            _query_params.append(('historyType', history_type))
            
        # process the header parameters
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )


        # authentication setting
        _auth_settings: List[str] = [
            'bearerAuth'
        ]

        return self.api_client.param_serialize(
            method='GET',
            resource_path='/v1/indicators/{type}/{value}/history',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def get_predictive_risk(
        self,
        type: Annotated[StrictStr, Field(description="Type of indicator")],
        value: Annotated[StrictStr, Field(description="The indicator value (IP address or domain)")],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> PredictiveRiskResponse:
        """Get AI Predictive Risk Score

        <p>Returns ML-based predictive risk assessment for an IP address or domain. Provides current risk scoring, 7-day and 30-day predictions, risk trajectory analysis, and contributing factors.</p> <h4>Response Includes:</h4> <ul>     <li><b>Current Assessment:</b> Risk score (0-100), risk level, and confidence</li>     <li><b>Predictions:</b> 7-day and 30-day risk forecasts with confidence intervals</li>     <li><b>Trajectory:</b> Trend direction (improving/stable/worsening), velocity, stability</li>     <li><b>Risk Factors:</b> Contributing factors with weights and descriptions</li>     <li><b>Early Warnings:</b> Signals indicating potential future risk changes</li>     <li><b>Similar Cases:</b> Historical indicators with similar profiles and their outcomes</li> </ul> <h4>Risk Levels:</h4> <ul>     <li><b>low:</b> Score 0-30 - Minimal observed risk</li>     <li><b>medium:</b> Score 31-60 - Moderate risk, warrants monitoring</li>     <li><b>high:</b> Score 61-80 - Elevated risk, investigation recommended</li>     <li><b>critical:</b> Score 81-100 - Severe risk, immediate action advised</li> </ul> <h4>Performance:</h4> <p>Pre-computed ML predictions. Response time typically under 500ms with 15-minute cache.</p> 

        :param type: Type of indicator (required)
        :type type: str
        :param value: The indicator value (IP address or domain) (required)
        :type value: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._get_predictive_risk_serialize(
            type=type,
            value=value,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "PredictiveRiskResponse",
            '400': "ErrorResponse",
            '401': "ErrorResponse",
            '404': "ErrorResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def get_predictive_risk_with_http_info(
        self,
        type: Annotated[StrictStr, Field(description="Type of indicator")],
        value: Annotated[StrictStr, Field(description="The indicator value (IP address or domain)")],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[PredictiveRiskResponse]:
        """Get AI Predictive Risk Score

        <p>Returns ML-based predictive risk assessment for an IP address or domain. Provides current risk scoring, 7-day and 30-day predictions, risk trajectory analysis, and contributing factors.</p> <h4>Response Includes:</h4> <ul>     <li><b>Current Assessment:</b> Risk score (0-100), risk level, and confidence</li>     <li><b>Predictions:</b> 7-day and 30-day risk forecasts with confidence intervals</li>     <li><b>Trajectory:</b> Trend direction (improving/stable/worsening), velocity, stability</li>     <li><b>Risk Factors:</b> Contributing factors with weights and descriptions</li>     <li><b>Early Warnings:</b> Signals indicating potential future risk changes</li>     <li><b>Similar Cases:</b> Historical indicators with similar profiles and their outcomes</li> </ul> <h4>Risk Levels:</h4> <ul>     <li><b>low:</b> Score 0-30 - Minimal observed risk</li>     <li><b>medium:</b> Score 31-60 - Moderate risk, warrants monitoring</li>     <li><b>high:</b> Score 61-80 - Elevated risk, investigation recommended</li>     <li><b>critical:</b> Score 81-100 - Severe risk, immediate action advised</li> </ul> <h4>Performance:</h4> <p>Pre-computed ML predictions. Response time typically under 500ms with 15-minute cache.</p> 

        :param type: Type of indicator (required)
        :type type: str
        :param value: The indicator value (IP address or domain) (required)
        :type value: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._get_predictive_risk_serialize(
            type=type,
            value=value,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "PredictiveRiskResponse",
            '400': "ErrorResponse",
            '401': "ErrorResponse",
            '404': "ErrorResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def get_predictive_risk_without_preload_content(
        self,
        type: Annotated[StrictStr, Field(description="Type of indicator")],
        value: Annotated[StrictStr, Field(description="The indicator value (IP address or domain)")],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """Get AI Predictive Risk Score

        <p>Returns ML-based predictive risk assessment for an IP address or domain. Provides current risk scoring, 7-day and 30-day predictions, risk trajectory analysis, and contributing factors.</p> <h4>Response Includes:</h4> <ul>     <li><b>Current Assessment:</b> Risk score (0-100), risk level, and confidence</li>     <li><b>Predictions:</b> 7-day and 30-day risk forecasts with confidence intervals</li>     <li><b>Trajectory:</b> Trend direction (improving/stable/worsening), velocity, stability</li>     <li><b>Risk Factors:</b> Contributing factors with weights and descriptions</li>     <li><b>Early Warnings:</b> Signals indicating potential future risk changes</li>     <li><b>Similar Cases:</b> Historical indicators with similar profiles and their outcomes</li> </ul> <h4>Risk Levels:</h4> <ul>     <li><b>low:</b> Score 0-30 - Minimal observed risk</li>     <li><b>medium:</b> Score 31-60 - Moderate risk, warrants monitoring</li>     <li><b>high:</b> Score 61-80 - Elevated risk, investigation recommended</li>     <li><b>critical:</b> Score 81-100 - Severe risk, immediate action advised</li> </ul> <h4>Performance:</h4> <p>Pre-computed ML predictions. Response time typically under 500ms with 15-minute cache.</p> 

        :param type: Type of indicator (required)
        :type type: str
        :param value: The indicator value (IP address or domain) (required)
        :type value: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._get_predictive_risk_serialize(
            type=type,
            value=value,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "PredictiveRiskResponse",
            '400': "ErrorResponse",
            '401': "ErrorResponse",
            '404': "ErrorResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _get_predictive_risk_serialize(
        self,
        type,
        value,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        if type is not None:
            _path_params['type'] = type
        if value is not None:
            _path_params['value'] = value
        # process the query parameters
        # process the header parameters
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )


        # authentication setting
        _auth_settings: List[str] = [
            'bearerAuth'
        ]

        return self.api_client.param_serialize(
            method='GET',
            resource_path='/v1/indicators/{type}/{value}/predictive-risk',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def get_subdomains(
        self,
        domain: Annotated[StrictStr, Field(description="The root domain to query for subdomains.")],
        limit: Annotated[Optional[StrictInt], Field(description="The maximum number of subdomains to return.")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> SubdomainResponse:
        """Get Domain Subdomains

        Retrieves a list of discovered subdomains for a given root domain, based on passive DNS and other enumeration techniques.

        :param domain: The root domain to query for subdomains. (required)
        :type domain: str
        :param limit: The maximum number of subdomains to return.
        :type limit: int
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._get_subdomains_serialize(
            domain=domain,
            limit=limit,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "SubdomainResponse",
            '400': "ErrorResponse",
            '401': "ErrorResponse",
            '404': "ErrorResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def get_subdomains_with_http_info(
        self,
        domain: Annotated[StrictStr, Field(description="The root domain to query for subdomains.")],
        limit: Annotated[Optional[StrictInt], Field(description="The maximum number of subdomains to return.")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[SubdomainResponse]:
        """Get Domain Subdomains

        Retrieves a list of discovered subdomains for a given root domain, based on passive DNS and other enumeration techniques.

        :param domain: The root domain to query for subdomains. (required)
        :type domain: str
        :param limit: The maximum number of subdomains to return.
        :type limit: int
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._get_subdomains_serialize(
            domain=domain,
            limit=limit,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "SubdomainResponse",
            '400': "ErrorResponse",
            '401': "ErrorResponse",
            '404': "ErrorResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def get_subdomains_without_preload_content(
        self,
        domain: Annotated[StrictStr, Field(description="The root domain to query for subdomains.")],
        limit: Annotated[Optional[StrictInt], Field(description="The maximum number of subdomains to return.")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """Get Domain Subdomains

        Retrieves a list of discovered subdomains for a given root domain, based on passive DNS and other enumeration techniques.

        :param domain: The root domain to query for subdomains. (required)
        :type domain: str
        :param limit: The maximum number of subdomains to return.
        :type limit: int
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._get_subdomains_serialize(
            domain=domain,
            limit=limit,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "SubdomainResponse",
            '400': "ErrorResponse",
            '401': "ErrorResponse",
            '404': "ErrorResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _get_subdomains_serialize(
        self,
        domain,
        limit,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        if domain is not None:
            _path_params['domain'] = domain
        # process the query parameters
        if limit is not None:
            
            _query_params.append(('limit', limit))
            
        # process the header parameters
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )


        # authentication setting
        _auth_settings: List[str] = [
            'bearerAuth'
        ]

        return self.api_client.param_serialize(
            method='GET',
            resource_path='/v1/indicators/domain/{domain}/subdomains',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def search_indicators(
        self,
        search_request: Annotated[SearchRequest, Field(description="The search query and configuration.")],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> SearchResponse:
        """Search WHOIS and Geolocation Records (Asynchronous)

                    <p>Initiates an asynchronous job to search domain registration (WHOIS) or IP geolocation records. This endpoint is extremely powerful for infrastructure discovery, threat hunting, and brand protection.</p>             <p><b>Performance Note:</b> WHOIS searches are data-intensive and can take over 50 seconds to complete. Geolocation searches are faster (5-10 seconds). This endpoint is asynchronous by design. Poll the <code>/v1/ops/jobs/{jobId}</code> endpoint to retrieve results.</p>              <h4>Search Types:</h4>             <p>The endpoint automatically routes to the appropriate backend based on the fields provided:</p>             <ul>                 <li><b>WHOIS Search:</b> Use registrant fields (registrantCompany, registrantEmail, etc.) or domain-related fields (tld, nameServer, etc.)</li>                 <li><b>Geolocation Search:</b> Use IP geolocation fields (city, country, asn, isp, etc.) to find IPs matching criteria</li>             </ul>              <h4>WHOIS Search Fields:</h4>             <table>                 <tr><th>Field</th><th>Type</th><th>Description</th></tr>                 <tr><td><code>tld</code></td><td>exact</td><td>Top-level domain (e.g., \"com\", \"org\", \"net\")</td></tr>                 <tr><td><code>registrarName</code></td><td>exact</td><td>Domain registrar name</td></tr>                 <tr><td><code>registrarIanaId</code></td><td>exact</td><td>IANA registrar ID</td></tr>                 <tr><td><code>registrantName</code></td><td>text</td><td>Domain registrant name (partial match)</td></tr>                 <tr><td><code>registrantCompany</code></td><td>text</td><td>Registrant organization/company (partial match)</td></tr>                 <tr><td><code>registrantEmail</code></td><td>text</td><td>Registrant email address (supports *@domain.com wildcards)</td></tr>                 <tr><td><code>registrantPhone</code></td><td>text</td><td>Registrant phone number</td></tr>                 <tr><td><code>registrantCountry</code></td><td>text</td><td>2-letter country code (e.g., \"US\", \"DE\")</td></tr>                 <tr><td><code>registrantCity</code></td><td>text</td><td>Registrant city</td></tr>                 <tr><td><code>nameServer</code></td><td>text</td><td>Name server hostname</td></tr>                 <tr><td><code>domainStatus</code></td><td>text</td><td>Domain status flag (e.g., \"clientTransferProhibited\")</td></tr>                 <tr><td><code>createdDate</code></td><td>exact</td><td>Domain creation date (YYYY-MM-DD format)</td></tr>                 <tr><td><code>updatedDate</code></td><td>exact</td><td>Domain last update date (YYYY-MM-DD format)</td></tr>                 <tr><td><code>expiryDate</code></td><td>exact</td><td>Domain expiry date (YYYY-MM-DD format)</td></tr>             </table>              <h4>Geolocation Search Fields (query string syntax):</h4>             <table>                 <tr><th>Field</th><th>Description</th><th>Example</th></tr>                 <tr><td><code>city</code></td><td>City name</td><td><code>city:London</code></td></tr>                 <tr><td><code>country</code></td><td>Country name</td><td><code>country:Germany</code></td></tr>                 <tr><td><code>asn</code></td><td>Autonomous System Number</td><td><code>asn:15169</code> (Google)</td></tr>                 <tr><td><code>isp</code></td><td>Internet Service Provider name</td><td><code>isp:Cloudflare</code></td></tr>                 <tr><td><code>organization</code></td><td>Organization name</td><td><code>organization:Amazon</code></td></tr>                 <tr><td><code>region</code></td><td>Region/State</td><td><code>region:California</code></td></tr>                 <tr><td><code>postal_code</code></td><td>Postal/ZIP code</td><td><code>postal_code:94043</code></td></tr>                 <tr><td><code>continent</code></td><td>Continent</td><td><code>continent:Europe</code></td></tr>             </table>              <h4>Example Requests:</h4>             <p><b>WHOIS search (field-based):</b></p>             <pre>{   \"registrantCompany\": \"Google\",   \"registrantCountry\": \"US\",   \"limit\": 100,   \"page\": 0 }</pre>             <p><b>Geolocation search (find IPs by ASN):</b></p>             <pre>{   \"query\": \"asn:15169\",   \"limit\": 100 }</pre>             <p><b>Geolocation search (find IPs by city):</b></p>             <pre>{   \"query\": \"city:Mountain View\",   \"limit\": 100 }</pre>             <p><b>Date-based domain search:</b></p>             <pre>{   \"createdDate\": \"2024-01-15\",   \"tld\": \"com\",   \"limit\": 100 }</pre>              <h4>Pagination:</h4>             <ul>                 <li><code>limit</code>: Maximum 100 results per page (default: 100)</li>                 <li><code>page</code>: 0-indexed page number (default: 0)</li>                 <li><code>offset</code>: Alternative to page - number of results to skip</li>             </ul>              <h4>Use Cases:</h4>             <ul>                 <li><b>Threat hunting:</b> Find domains/IPs registered by known malicious actors</li>                 <li><b>Infrastructure mapping:</b> Find all IPs in a specific ASN or organization</li>                 <li><b>Brand protection:</b> Monitor for domains similar to your brand</li>                 <li><b>Geolocation analysis:</b> Find IPs in specific geographic regions</li>                 <li><b>Investigation:</b> Track domains created on specific dates or IPs from specific ISPs</li>             </ul>              <h4>Security:</h4>             <p>All search parameters are validated for:</p>             <ul>                 <li>SQL injection prevention</li>                 <li>Command injection prevention</li>                 <li>Input length limits</li>                 <li>Format validation (dates, emails, country codes, etc.)</li>             </ul> 

        :param search_request: The search query and configuration. (required)
        :type search_request: SearchRequest
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._search_indicators_serialize(
            search_request=search_request,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '202': "JobResponse",
            '200': "SearchResponse",
            '400': "ErrorResponse",
            '401': "ErrorResponse",
            '429': "ErrorResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def search_indicators_with_http_info(
        self,
        search_request: Annotated[SearchRequest, Field(description="The search query and configuration.")],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[SearchResponse]:
        """Search WHOIS and Geolocation Records (Asynchronous)

                    <p>Initiates an asynchronous job to search domain registration (WHOIS) or IP geolocation records. This endpoint is extremely powerful for infrastructure discovery, threat hunting, and brand protection.</p>             <p><b>Performance Note:</b> WHOIS searches are data-intensive and can take over 50 seconds to complete. Geolocation searches are faster (5-10 seconds). This endpoint is asynchronous by design. Poll the <code>/v1/ops/jobs/{jobId}</code> endpoint to retrieve results.</p>              <h4>Search Types:</h4>             <p>The endpoint automatically routes to the appropriate backend based on the fields provided:</p>             <ul>                 <li><b>WHOIS Search:</b> Use registrant fields (registrantCompany, registrantEmail, etc.) or domain-related fields (tld, nameServer, etc.)</li>                 <li><b>Geolocation Search:</b> Use IP geolocation fields (city, country, asn, isp, etc.) to find IPs matching criteria</li>             </ul>              <h4>WHOIS Search Fields:</h4>             <table>                 <tr><th>Field</th><th>Type</th><th>Description</th></tr>                 <tr><td><code>tld</code></td><td>exact</td><td>Top-level domain (e.g., \"com\", \"org\", \"net\")</td></tr>                 <tr><td><code>registrarName</code></td><td>exact</td><td>Domain registrar name</td></tr>                 <tr><td><code>registrarIanaId</code></td><td>exact</td><td>IANA registrar ID</td></tr>                 <tr><td><code>registrantName</code></td><td>text</td><td>Domain registrant name (partial match)</td></tr>                 <tr><td><code>registrantCompany</code></td><td>text</td><td>Registrant organization/company (partial match)</td></tr>                 <tr><td><code>registrantEmail</code></td><td>text</td><td>Registrant email address (supports *@domain.com wildcards)</td></tr>                 <tr><td><code>registrantPhone</code></td><td>text</td><td>Registrant phone number</td></tr>                 <tr><td><code>registrantCountry</code></td><td>text</td><td>2-letter country code (e.g., \"US\", \"DE\")</td></tr>                 <tr><td><code>registrantCity</code></td><td>text</td><td>Registrant city</td></tr>                 <tr><td><code>nameServer</code></td><td>text</td><td>Name server hostname</td></tr>                 <tr><td><code>domainStatus</code></td><td>text</td><td>Domain status flag (e.g., \"clientTransferProhibited\")</td></tr>                 <tr><td><code>createdDate</code></td><td>exact</td><td>Domain creation date (YYYY-MM-DD format)</td></tr>                 <tr><td><code>updatedDate</code></td><td>exact</td><td>Domain last update date (YYYY-MM-DD format)</td></tr>                 <tr><td><code>expiryDate</code></td><td>exact</td><td>Domain expiry date (YYYY-MM-DD format)</td></tr>             </table>              <h4>Geolocation Search Fields (query string syntax):</h4>             <table>                 <tr><th>Field</th><th>Description</th><th>Example</th></tr>                 <tr><td><code>city</code></td><td>City name</td><td><code>city:London</code></td></tr>                 <tr><td><code>country</code></td><td>Country name</td><td><code>country:Germany</code></td></tr>                 <tr><td><code>asn</code></td><td>Autonomous System Number</td><td><code>asn:15169</code> (Google)</td></tr>                 <tr><td><code>isp</code></td><td>Internet Service Provider name</td><td><code>isp:Cloudflare</code></td></tr>                 <tr><td><code>organization</code></td><td>Organization name</td><td><code>organization:Amazon</code></td></tr>                 <tr><td><code>region</code></td><td>Region/State</td><td><code>region:California</code></td></tr>                 <tr><td><code>postal_code</code></td><td>Postal/ZIP code</td><td><code>postal_code:94043</code></td></tr>                 <tr><td><code>continent</code></td><td>Continent</td><td><code>continent:Europe</code></td></tr>             </table>              <h4>Example Requests:</h4>             <p><b>WHOIS search (field-based):</b></p>             <pre>{   \"registrantCompany\": \"Google\",   \"registrantCountry\": \"US\",   \"limit\": 100,   \"page\": 0 }</pre>             <p><b>Geolocation search (find IPs by ASN):</b></p>             <pre>{   \"query\": \"asn:15169\",   \"limit\": 100 }</pre>             <p><b>Geolocation search (find IPs by city):</b></p>             <pre>{   \"query\": \"city:Mountain View\",   \"limit\": 100 }</pre>             <p><b>Date-based domain search:</b></p>             <pre>{   \"createdDate\": \"2024-01-15\",   \"tld\": \"com\",   \"limit\": 100 }</pre>              <h4>Pagination:</h4>             <ul>                 <li><code>limit</code>: Maximum 100 results per page (default: 100)</li>                 <li><code>page</code>: 0-indexed page number (default: 0)</li>                 <li><code>offset</code>: Alternative to page - number of results to skip</li>             </ul>              <h4>Use Cases:</h4>             <ul>                 <li><b>Threat hunting:</b> Find domains/IPs registered by known malicious actors</li>                 <li><b>Infrastructure mapping:</b> Find all IPs in a specific ASN or organization</li>                 <li><b>Brand protection:</b> Monitor for domains similar to your brand</li>                 <li><b>Geolocation analysis:</b> Find IPs in specific geographic regions</li>                 <li><b>Investigation:</b> Track domains created on specific dates or IPs from specific ISPs</li>             </ul>              <h4>Security:</h4>             <p>All search parameters are validated for:</p>             <ul>                 <li>SQL injection prevention</li>                 <li>Command injection prevention</li>                 <li>Input length limits</li>                 <li>Format validation (dates, emails, country codes, etc.)</li>             </ul> 

        :param search_request: The search query and configuration. (required)
        :type search_request: SearchRequest
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._search_indicators_serialize(
            search_request=search_request,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '202': "JobResponse",
            '200': "SearchResponse",
            '400': "ErrorResponse",
            '401': "ErrorResponse",
            '429': "ErrorResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def search_indicators_without_preload_content(
        self,
        search_request: Annotated[SearchRequest, Field(description="The search query and configuration.")],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """Search WHOIS and Geolocation Records (Asynchronous)

                    <p>Initiates an asynchronous job to search domain registration (WHOIS) or IP geolocation records. This endpoint is extremely powerful for infrastructure discovery, threat hunting, and brand protection.</p>             <p><b>Performance Note:</b> WHOIS searches are data-intensive and can take over 50 seconds to complete. Geolocation searches are faster (5-10 seconds). This endpoint is asynchronous by design. Poll the <code>/v1/ops/jobs/{jobId}</code> endpoint to retrieve results.</p>              <h4>Search Types:</h4>             <p>The endpoint automatically routes to the appropriate backend based on the fields provided:</p>             <ul>                 <li><b>WHOIS Search:</b> Use registrant fields (registrantCompany, registrantEmail, etc.) or domain-related fields (tld, nameServer, etc.)</li>                 <li><b>Geolocation Search:</b> Use IP geolocation fields (city, country, asn, isp, etc.) to find IPs matching criteria</li>             </ul>              <h4>WHOIS Search Fields:</h4>             <table>                 <tr><th>Field</th><th>Type</th><th>Description</th></tr>                 <tr><td><code>tld</code></td><td>exact</td><td>Top-level domain (e.g., \"com\", \"org\", \"net\")</td></tr>                 <tr><td><code>registrarName</code></td><td>exact</td><td>Domain registrar name</td></tr>                 <tr><td><code>registrarIanaId</code></td><td>exact</td><td>IANA registrar ID</td></tr>                 <tr><td><code>registrantName</code></td><td>text</td><td>Domain registrant name (partial match)</td></tr>                 <tr><td><code>registrantCompany</code></td><td>text</td><td>Registrant organization/company (partial match)</td></tr>                 <tr><td><code>registrantEmail</code></td><td>text</td><td>Registrant email address (supports *@domain.com wildcards)</td></tr>                 <tr><td><code>registrantPhone</code></td><td>text</td><td>Registrant phone number</td></tr>                 <tr><td><code>registrantCountry</code></td><td>text</td><td>2-letter country code (e.g., \"US\", \"DE\")</td></tr>                 <tr><td><code>registrantCity</code></td><td>text</td><td>Registrant city</td></tr>                 <tr><td><code>nameServer</code></td><td>text</td><td>Name server hostname</td></tr>                 <tr><td><code>domainStatus</code></td><td>text</td><td>Domain status flag (e.g., \"clientTransferProhibited\")</td></tr>                 <tr><td><code>createdDate</code></td><td>exact</td><td>Domain creation date (YYYY-MM-DD format)</td></tr>                 <tr><td><code>updatedDate</code></td><td>exact</td><td>Domain last update date (YYYY-MM-DD format)</td></tr>                 <tr><td><code>expiryDate</code></td><td>exact</td><td>Domain expiry date (YYYY-MM-DD format)</td></tr>             </table>              <h4>Geolocation Search Fields (query string syntax):</h4>             <table>                 <tr><th>Field</th><th>Description</th><th>Example</th></tr>                 <tr><td><code>city</code></td><td>City name</td><td><code>city:London</code></td></tr>                 <tr><td><code>country</code></td><td>Country name</td><td><code>country:Germany</code></td></tr>                 <tr><td><code>asn</code></td><td>Autonomous System Number</td><td><code>asn:15169</code> (Google)</td></tr>                 <tr><td><code>isp</code></td><td>Internet Service Provider name</td><td><code>isp:Cloudflare</code></td></tr>                 <tr><td><code>organization</code></td><td>Organization name</td><td><code>organization:Amazon</code></td></tr>                 <tr><td><code>region</code></td><td>Region/State</td><td><code>region:California</code></td></tr>                 <tr><td><code>postal_code</code></td><td>Postal/ZIP code</td><td><code>postal_code:94043</code></td></tr>                 <tr><td><code>continent</code></td><td>Continent</td><td><code>continent:Europe</code></td></tr>             </table>              <h4>Example Requests:</h4>             <p><b>WHOIS search (field-based):</b></p>             <pre>{   \"registrantCompany\": \"Google\",   \"registrantCountry\": \"US\",   \"limit\": 100,   \"page\": 0 }</pre>             <p><b>Geolocation search (find IPs by ASN):</b></p>             <pre>{   \"query\": \"asn:15169\",   \"limit\": 100 }</pre>             <p><b>Geolocation search (find IPs by city):</b></p>             <pre>{   \"query\": \"city:Mountain View\",   \"limit\": 100 }</pre>             <p><b>Date-based domain search:</b></p>             <pre>{   \"createdDate\": \"2024-01-15\",   \"tld\": \"com\",   \"limit\": 100 }</pre>              <h4>Pagination:</h4>             <ul>                 <li><code>limit</code>: Maximum 100 results per page (default: 100)</li>                 <li><code>page</code>: 0-indexed page number (default: 0)</li>                 <li><code>offset</code>: Alternative to page - number of results to skip</li>             </ul>              <h4>Use Cases:</h4>             <ul>                 <li><b>Threat hunting:</b> Find domains/IPs registered by known malicious actors</li>                 <li><b>Infrastructure mapping:</b> Find all IPs in a specific ASN or organization</li>                 <li><b>Brand protection:</b> Monitor for domains similar to your brand</li>                 <li><b>Geolocation analysis:</b> Find IPs in specific geographic regions</li>                 <li><b>Investigation:</b> Track domains created on specific dates or IPs from specific ISPs</li>             </ul>              <h4>Security:</h4>             <p>All search parameters are validated for:</p>             <ul>                 <li>SQL injection prevention</li>                 <li>Command injection prevention</li>                 <li>Input length limits</li>                 <li>Format validation (dates, emails, country codes, etc.)</li>             </ul> 

        :param search_request: The search query and configuration. (required)
        :type search_request: SearchRequest
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._search_indicators_serialize(
            search_request=search_request,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '202': "JobResponse",
            '200': "SearchResponse",
            '400': "ErrorResponse",
            '401': "ErrorResponse",
            '429': "ErrorResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _search_indicators_serialize(
        self,
        search_request,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        # process the query parameters
        # process the header parameters
        # process the form parameters
        # process the body parameter
        if search_request is not None:
            _body_params = search_request


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )

        # set the HTTP header `Content-Type`
        if _content_type:
            _header_params['Content-Type'] = _content_type
        else:
            _default_content_type = (
                self.api_client.select_header_content_type(
                    [
                        'application/json'
                    ]
                )
            )
            if _default_content_type is not None:
                _header_params['Content-Type'] = _default_content_type

        # authentication setting
        _auth_settings: List[str] = [
            'bearerAuth'
        ]

        return self.api_client.param_serialize(
            method='POST',
            resource_path='/v1/ops/enrichment/search',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def similar_domains(
        self,
        similar_domains_ops_request: Annotated[SimilarDomainsOpsRequest, Field(description="Similar domains request with domain and options.")],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> SimilarDomainsResponse:
        """Find Similar Domains (Asynchronous)

        <p>Finds domains similar to the provided domain using various similarity detection techniques. This endpoint is useful for brand protection, typosquatting detection, and threat hunting.</p>  <h4>Supported Techniques:</h4> <p>Specify techniques in the <code>techniques</code> array. If not specified, defaults to <code>typosquatting</code>.</p> <ul>     <li><b>typosquatting</b> - Keyboard proximity errors and common typos (e.g., gooogle.com, gogle.com)</li>     <li><b>homoglyph</b> - Visually similar Unicode characters (e.g., ggle.com using Cyrillic '')</li>     <li><b>tld_variation</b> - Different TLD variations (e.g., google.net, google.org)</li>     <li><b>sounding</b> - Phonetically similar domains</li>     <li><b>prefix</b> - Domains starting with the target</li>     <li><b>suffix</b> - Domains ending with the target</li>     <li><b>contains</b> - Domains containing the target as a substring</li>     <li><b>levenshtein</b> - Edit distance similarity</li> </ul>  <h4>Example Request:</h4> <pre><code>{   \"domain\": \"google.com\",   \"techniques\": [\"typosquatting\", \"homoglyph\", \"tld_variation\"],   \"limit\": 100 }</code></pre>  <h4>Response Format:</h4> <p>Poll <code>/v1/ops/jobs/{jobId}</code> to get results. The result contains:</p> <pre><code>{   \"domain\": \"google.com\",   \"status\": \"completed\",   \"similarDomains\": [     {\"domain\": \"gooogle.com\", \"technique\": \"TYPO\"},     {\"domain\": \"ggle.com\", \"technique\": \"UTFVARS\"}   ],   \"totalCount\": 200,   \"analysis\": {     \"techniquesUsed\": \"TYPO,UTFVARS\",     \"baseDomain\": \"google.com\",     \"searchLimit\": 100   } }</code></pre>  <h4>Performance:</h4> <p>Typically completes in 5-15 seconds. Multiple techniques run in parallel.</p>  <h4>Note:</h4> <p>The <code>check_registration</code>, <code>include_dns</code>, and <code>include_risk_score</code> options are not currently supported by the backend service and will be ignored.</p> 

        :param similar_domains_ops_request: Similar domains request with domain and options. (required)
        :type similar_domains_ops_request: SimilarDomainsOpsRequest
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._similar_domains_serialize(
            similar_domains_ops_request=similar_domains_ops_request,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '202': "JobResponse",
            '200': "SimilarDomainsResponse",
            '400': "ErrorResponse",
            '401': "ErrorResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def similar_domains_with_http_info(
        self,
        similar_domains_ops_request: Annotated[SimilarDomainsOpsRequest, Field(description="Similar domains request with domain and options.")],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[SimilarDomainsResponse]:
        """Find Similar Domains (Asynchronous)

        <p>Finds domains similar to the provided domain using various similarity detection techniques. This endpoint is useful for brand protection, typosquatting detection, and threat hunting.</p>  <h4>Supported Techniques:</h4> <p>Specify techniques in the <code>techniques</code> array. If not specified, defaults to <code>typosquatting</code>.</p> <ul>     <li><b>typosquatting</b> - Keyboard proximity errors and common typos (e.g., gooogle.com, gogle.com)</li>     <li><b>homoglyph</b> - Visually similar Unicode characters (e.g., ggle.com using Cyrillic '')</li>     <li><b>tld_variation</b> - Different TLD variations (e.g., google.net, google.org)</li>     <li><b>sounding</b> - Phonetically similar domains</li>     <li><b>prefix</b> - Domains starting with the target</li>     <li><b>suffix</b> - Domains ending with the target</li>     <li><b>contains</b> - Domains containing the target as a substring</li>     <li><b>levenshtein</b> - Edit distance similarity</li> </ul>  <h4>Example Request:</h4> <pre><code>{   \"domain\": \"google.com\",   \"techniques\": [\"typosquatting\", \"homoglyph\", \"tld_variation\"],   \"limit\": 100 }</code></pre>  <h4>Response Format:</h4> <p>Poll <code>/v1/ops/jobs/{jobId}</code> to get results. The result contains:</p> <pre><code>{   \"domain\": \"google.com\",   \"status\": \"completed\",   \"similarDomains\": [     {\"domain\": \"gooogle.com\", \"technique\": \"TYPO\"},     {\"domain\": \"ggle.com\", \"technique\": \"UTFVARS\"}   ],   \"totalCount\": 200,   \"analysis\": {     \"techniquesUsed\": \"TYPO,UTFVARS\",     \"baseDomain\": \"google.com\",     \"searchLimit\": 100   } }</code></pre>  <h4>Performance:</h4> <p>Typically completes in 5-15 seconds. Multiple techniques run in parallel.</p>  <h4>Note:</h4> <p>The <code>check_registration</code>, <code>include_dns</code>, and <code>include_risk_score</code> options are not currently supported by the backend service and will be ignored.</p> 

        :param similar_domains_ops_request: Similar domains request with domain and options. (required)
        :type similar_domains_ops_request: SimilarDomainsOpsRequest
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._similar_domains_serialize(
            similar_domains_ops_request=similar_domains_ops_request,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '202': "JobResponse",
            '200': "SimilarDomainsResponse",
            '400': "ErrorResponse",
            '401': "ErrorResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def similar_domains_without_preload_content(
        self,
        similar_domains_ops_request: Annotated[SimilarDomainsOpsRequest, Field(description="Similar domains request with domain and options.")],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """Find Similar Domains (Asynchronous)

        <p>Finds domains similar to the provided domain using various similarity detection techniques. This endpoint is useful for brand protection, typosquatting detection, and threat hunting.</p>  <h4>Supported Techniques:</h4> <p>Specify techniques in the <code>techniques</code> array. If not specified, defaults to <code>typosquatting</code>.</p> <ul>     <li><b>typosquatting</b> - Keyboard proximity errors and common typos (e.g., gooogle.com, gogle.com)</li>     <li><b>homoglyph</b> - Visually similar Unicode characters (e.g., ggle.com using Cyrillic '')</li>     <li><b>tld_variation</b> - Different TLD variations (e.g., google.net, google.org)</li>     <li><b>sounding</b> - Phonetically similar domains</li>     <li><b>prefix</b> - Domains starting with the target</li>     <li><b>suffix</b> - Domains ending with the target</li>     <li><b>contains</b> - Domains containing the target as a substring</li>     <li><b>levenshtein</b> - Edit distance similarity</li> </ul>  <h4>Example Request:</h4> <pre><code>{   \"domain\": \"google.com\",   \"techniques\": [\"typosquatting\", \"homoglyph\", \"tld_variation\"],   \"limit\": 100 }</code></pre>  <h4>Response Format:</h4> <p>Poll <code>/v1/ops/jobs/{jobId}</code> to get results. The result contains:</p> <pre><code>{   \"domain\": \"google.com\",   \"status\": \"completed\",   \"similarDomains\": [     {\"domain\": \"gooogle.com\", \"technique\": \"TYPO\"},     {\"domain\": \"ggle.com\", \"technique\": \"UTFVARS\"}   ],   \"totalCount\": 200,   \"analysis\": {     \"techniquesUsed\": \"TYPO,UTFVARS\",     \"baseDomain\": \"google.com\",     \"searchLimit\": 100   } }</code></pre>  <h4>Performance:</h4> <p>Typically completes in 5-15 seconds. Multiple techniques run in parallel.</p>  <h4>Note:</h4> <p>The <code>check_registration</code>, <code>include_dns</code>, and <code>include_risk_score</code> options are not currently supported by the backend service and will be ignored.</p> 

        :param similar_domains_ops_request: Similar domains request with domain and options. (required)
        :type similar_domains_ops_request: SimilarDomainsOpsRequest
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._similar_domains_serialize(
            similar_domains_ops_request=similar_domains_ops_request,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '202': "JobResponse",
            '200': "SimilarDomainsResponse",
            '400': "ErrorResponse",
            '401': "ErrorResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _similar_domains_serialize(
        self,
        similar_domains_ops_request,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        # process the query parameters
        # process the header parameters
        # process the form parameters
        # process the body parameter
        if similar_domains_ops_request is not None:
            _body_params = similar_domains_ops_request


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )

        # set the HTTP header `Content-Type`
        if _content_type:
            _header_params['Content-Type'] = _content_type
        else:
            _default_content_type = (
                self.api_client.select_header_content_type(
                    [
                        'application/json'
                    ]
                )
            )
            if _default_content_type is not None:
                _header_params['Content-Type'] = _default_content_type

        # authentication setting
        _auth_settings: List[str] = [
            'bearerAuth'
        ]

        return self.api_client.param_serialize(
            method='POST',
            resource_path='/v1/ops/enrichment/similar-domains',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )


