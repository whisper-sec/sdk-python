# coding: utf-8

"""
    Whisper Security API

    # Whisper Security Threat Intelligence API  The Whisper Security API provides comprehensive threat intelligence, geolocation data, and security operations capabilities for enterprise security teams and developers.  ## Key Capabilities  - **Indicator Enrichment**: Get comprehensive intelligence on IP addresses and domains including   geolocation, WHOIS, DNS, reputation scoring, and relationship mapping. - **Geolocation Services**: Fast IP-to-location lookups with ISP, ASN, and network information. - **Security Operations**: Asynchronous tools for bulk enrichment, infrastructure scanning,   AI-powered threat investigation, and monitoring.  ## API Design  - **RESTful**: Standard HTTP methods (GET, POST, PUT, DELETE) with JSON request/response bodies. - **Synchronous Endpoints**: Fast responses (<500ms) for indicator enrichment and geolocation. - **Asynchronous Jobs**: Long-running operations return a job ID for polling results. - **Consistent Error Handling**: Standardized error responses with status codes, error codes, and messages.  ## Authentication  All API endpoints require Bearer token authentication. Include your API key in the `Authorization` header: `Authorization: Bearer <your-api-key>`  ## Rate Limits  Rate limits are applied per-user and vary by endpoint category:  | Endpoint Category | Rate Limit | Description | |-------------------|------------|-------------| | Indicators (`/v1/indicators/*`) | 100 req/sec | Single indicator enrichment | | Location (`/v1/location/*`) | 100 req/sec | Geolocation lookups | | Jobs (`/v1/ops/jobs/*`) | 100 req/sec | Job status and listing | | Bulk Operations (`/v1/ops/enrichment/bulk`) | 10 req/sec | Bulk indicator processing | | Screenshots (`/v1/ops/screenshots/*`) | 10 req/sec | Screenshot capture and scheduling | | Scans (`/v1/ops/scans/*`) | 10 req/sec | Infrastructure scanning | | Monitoring (`/v1/ops/monitoring/*`) | 10 req/sec | Uptime monitoring | | Tracking (`/v1/ops/tracking/*`) | 10 req/sec | Change tracking | | AI Investigate (`/v1/ops/ai/investigate`) | 5 req/min | Deep threat investigation | | AI Correlate (`/v1/ops/ai/correlate`) | 5 req/min | Global correlation | | AI Attribute (`/v1/ops/ai/attribute`) | 5 req/min | Threat actor attribution | | AI Pivot (`/v1/ops/ai/pivot`) | 5 req/min | Infrastructure pivoting |  When rate limits are exceeded, the API returns HTTP `429 Too Many Requests` with a `Retry-After` header indicating when you can retry. The response body includes: ```json {   \"error\": \"Too Many Requests\",   \"message\": \"Rate limit exceeded for <category>. Please retry after N seconds.\",   \"retryAfter\": N } ```  ## Response Conventions  - All timestamps are in ISO 8601 format (UTC). - Pagination uses `limit` and `offset` parameters. - Field names use camelCase throughout the API.  ## Official SDKs  - **Python**: [github.com/whisper-sec/sdk-python](https://github.com/whisper-sec/sdk-python) - **TypeScript/JavaScript**: [github.com/whisper-sec/sdk-typescript](https://github.com/whisper-sec/sdk-typescript) - **Java**: [github.com/whisper-sec/sdk-java](https://github.com/whisper-sec/sdk-java) - **C#/.NET**: [github.com/whisper-sec/sdk-csharp](https://github.com/whisper-sec/sdk-csharp)  ## Resources  - **Website**: [whisper.security](https://whisper.security) - **Dashboard**: [dash.whisper.security](https://dash.whisper.security) - Manage API keys and view usage - **Documentation**: [docs.whisper.security](https://docs.whisper.security) - Guides and tutorials 

    The version of the OpenAPI document: 1.0.0
    Contact: support@whisper.security
    Generated by OpenAPI Generator (https://openapi-generator.tech)

    Do not edit the class manually.
"""  # noqa: E501

import warnings
from pydantic import validate_call, Field, StrictFloat, StrictStr, StrictInt
from typing import Any, Dict, List, Optional, Tuple, Union
from typing_extensions import Annotated

from pydantic import Field, StrictStr, field_validator
from typing import Optional
from typing_extensions import Annotated
from whisper_api_sdk.models.attribute_request import AttributeRequest
from whisper_api_sdk.models.attribute_result import AttributeResult
from whisper_api_sdk.models.benchmark_response import BenchmarkResponse
from whisper_api_sdk.models.correlate_request import CorrelateRequest
from whisper_api_sdk.models.correlate_result import CorrelateResult
from whisper_api_sdk.models.investigate_request import InvestigateRequest
from whisper_api_sdk.models.investigate_result import InvestigateResult
from whisper_api_sdk.models.pivot_request import PivotRequest
from whisper_api_sdk.models.pivot_result import PivotResult
from whisper_api_sdk.models.similar_cases_request import SimilarCasesRequest
from whisper_api_sdk.models.similar_cases_result import SimilarCasesResult

from whisper_api_sdk.api_client import ApiClient, RequestSerialized
from whisper_api_sdk.api_response import ApiResponse
from whisper_api_sdk.rest import RESTResponseType


class AIIntelligenceApi:
    """NOTE: This class is auto generated by OpenAPI Generator
    Ref: https://openapi-generator.tech

    Do not edit the class manually.
    """

    def __init__(self, api_client=None) -> None:
        if api_client is None:
            api_client = ApiClient.get_default()
        self.api_client = api_client


    @validate_call
    def ai_attribute(
        self,
        attribute_request: Annotated[AttributeRequest, Field(description="Attribution request")],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> AttributeResult:
        """Threat Actor Attribution (Asynchronous)

        <p>Analyzes indicators and context to identify potential threat actors and campaigns. Uses ML clustering and TTP matching against known threat actor profiles.</p> <h4>Attribution Analysis:</h4> <ul>     <li><b>Actor Identification:</b> Potential threat actor matches with confidence</li>     <li><b>Campaign Clustering:</b> Groups indicators into potential campaigns</li>     <li><b>TTP Mapping:</b> MITRE ATT&CK technique mapping</li>     <li><b>Historical Context:</b> Known actor activity patterns</li> </ul> <h4>Limitations:</h4> <p>Maximum 500 indicators per request. Attribution is probabilistic and should be validated.</p> <h4>Performance:</h4> <p>Campaign clustering and analysis. Expected: 60-300 seconds.</p> 

        :param attribute_request: Attribution request (required)
        :type attribute_request: AttributeRequest
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._ai_attribute_serialize(
            attribute_request=attribute_request,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '202': "JobResponse",
            '200': "AttributeResult",
            '400': "ErrorResponse",
            '401': "ErrorResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def ai_attribute_with_http_info(
        self,
        attribute_request: Annotated[AttributeRequest, Field(description="Attribution request")],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[AttributeResult]:
        """Threat Actor Attribution (Asynchronous)

        <p>Analyzes indicators and context to identify potential threat actors and campaigns. Uses ML clustering and TTP matching against known threat actor profiles.</p> <h4>Attribution Analysis:</h4> <ul>     <li><b>Actor Identification:</b> Potential threat actor matches with confidence</li>     <li><b>Campaign Clustering:</b> Groups indicators into potential campaigns</li>     <li><b>TTP Mapping:</b> MITRE ATT&CK technique mapping</li>     <li><b>Historical Context:</b> Known actor activity patterns</li> </ul> <h4>Limitations:</h4> <p>Maximum 500 indicators per request. Attribution is probabilistic and should be validated.</p> <h4>Performance:</h4> <p>Campaign clustering and analysis. Expected: 60-300 seconds.</p> 

        :param attribute_request: Attribution request (required)
        :type attribute_request: AttributeRequest
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._ai_attribute_serialize(
            attribute_request=attribute_request,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '202': "JobResponse",
            '200': "AttributeResult",
            '400': "ErrorResponse",
            '401': "ErrorResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def ai_attribute_without_preload_content(
        self,
        attribute_request: Annotated[AttributeRequest, Field(description="Attribution request")],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """Threat Actor Attribution (Asynchronous)

        <p>Analyzes indicators and context to identify potential threat actors and campaigns. Uses ML clustering and TTP matching against known threat actor profiles.</p> <h4>Attribution Analysis:</h4> <ul>     <li><b>Actor Identification:</b> Potential threat actor matches with confidence</li>     <li><b>Campaign Clustering:</b> Groups indicators into potential campaigns</li>     <li><b>TTP Mapping:</b> MITRE ATT&CK technique mapping</li>     <li><b>Historical Context:</b> Known actor activity patterns</li> </ul> <h4>Limitations:</h4> <p>Maximum 500 indicators per request. Attribution is probabilistic and should be validated.</p> <h4>Performance:</h4> <p>Campaign clustering and analysis. Expected: 60-300 seconds.</p> 

        :param attribute_request: Attribution request (required)
        :type attribute_request: AttributeRequest
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._ai_attribute_serialize(
            attribute_request=attribute_request,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '202': "JobResponse",
            '200': "AttributeResult",
            '400': "ErrorResponse",
            '401': "ErrorResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _ai_attribute_serialize(
        self,
        attribute_request,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        # process the query parameters
        # process the header parameters
        # process the form parameters
        # process the body parameter
        if attribute_request is not None:
            _body_params = attribute_request


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )

        # set the HTTP header `Content-Type`
        if _content_type:
            _header_params['Content-Type'] = _content_type
        else:
            _default_content_type = (
                self.api_client.select_header_content_type(
                    [
                        'application/json'
                    ]
                )
            )
            if _default_content_type is not None:
                _header_params['Content-Type'] = _default_content_type

        # authentication setting
        _auth_settings: List[str] = [
            'bearerAuth'
        ]

        return self.api_client.param_serialize(
            method='POST',
            resource_path='/v1/ops/ai/attribute',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def ai_correlate(
        self,
        correlate_request: Annotated[CorrelateRequest, Field(description="Correlation request")],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> CorrelateResult:
        """Global Indicator Correlation (Asynchronous)

        <p>Correlates your indicators against anonymized global threat data from all customers. Identifies shared campaigns, widespread threats, and prevalence across industries.</p> <h4>Correlation Analysis:</h4> <ul>     <li><b>Prevalence:</b> How common are these indicators across our customer base</li>     <li><b>Industry Breakdown:</b> Which industries are seeing these indicators</li>     <li><b>Campaign Detection:</b> Are these part of a broader campaign</li>     <li><b>First/Last Seen:</b> Global timeline of indicator activity</li>     <li><b>Co-occurrence:</b> Indicators frequently seen together</li> </ul> <h4>Limitations:</h4> <p>Maximum 100 indicators per request.</p> <h4>Performance:</h4> <p>Cross-customer correlation. Expected: 10-60 seconds.</p> 

        :param correlate_request: Correlation request (required)
        :type correlate_request: CorrelateRequest
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._ai_correlate_serialize(
            correlate_request=correlate_request,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '202': "JobResponse",
            '200': "CorrelateResult",
            '400': "ErrorResponse",
            '401': "ErrorResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def ai_correlate_with_http_info(
        self,
        correlate_request: Annotated[CorrelateRequest, Field(description="Correlation request")],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[CorrelateResult]:
        """Global Indicator Correlation (Asynchronous)

        <p>Correlates your indicators against anonymized global threat data from all customers. Identifies shared campaigns, widespread threats, and prevalence across industries.</p> <h4>Correlation Analysis:</h4> <ul>     <li><b>Prevalence:</b> How common are these indicators across our customer base</li>     <li><b>Industry Breakdown:</b> Which industries are seeing these indicators</li>     <li><b>Campaign Detection:</b> Are these part of a broader campaign</li>     <li><b>First/Last Seen:</b> Global timeline of indicator activity</li>     <li><b>Co-occurrence:</b> Indicators frequently seen together</li> </ul> <h4>Limitations:</h4> <p>Maximum 100 indicators per request.</p> <h4>Performance:</h4> <p>Cross-customer correlation. Expected: 10-60 seconds.</p> 

        :param correlate_request: Correlation request (required)
        :type correlate_request: CorrelateRequest
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._ai_correlate_serialize(
            correlate_request=correlate_request,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '202': "JobResponse",
            '200': "CorrelateResult",
            '400': "ErrorResponse",
            '401': "ErrorResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def ai_correlate_without_preload_content(
        self,
        correlate_request: Annotated[CorrelateRequest, Field(description="Correlation request")],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """Global Indicator Correlation (Asynchronous)

        <p>Correlates your indicators against anonymized global threat data from all customers. Identifies shared campaigns, widespread threats, and prevalence across industries.</p> <h4>Correlation Analysis:</h4> <ul>     <li><b>Prevalence:</b> How common are these indicators across our customer base</li>     <li><b>Industry Breakdown:</b> Which industries are seeing these indicators</li>     <li><b>Campaign Detection:</b> Are these part of a broader campaign</li>     <li><b>First/Last Seen:</b> Global timeline of indicator activity</li>     <li><b>Co-occurrence:</b> Indicators frequently seen together</li> </ul> <h4>Limitations:</h4> <p>Maximum 100 indicators per request.</p> <h4>Performance:</h4> <p>Cross-customer correlation. Expected: 10-60 seconds.</p> 

        :param correlate_request: Correlation request (required)
        :type correlate_request: CorrelateRequest
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._ai_correlate_serialize(
            correlate_request=correlate_request,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '202': "JobResponse",
            '200': "CorrelateResult",
            '400': "ErrorResponse",
            '401': "ErrorResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _ai_correlate_serialize(
        self,
        correlate_request,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        # process the query parameters
        # process the header parameters
        # process the form parameters
        # process the body parameter
        if correlate_request is not None:
            _body_params = correlate_request


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )

        # set the HTTP header `Content-Type`
        if _content_type:
            _header_params['Content-Type'] = _content_type
        else:
            _default_content_type = (
                self.api_client.select_header_content_type(
                    [
                        'application/json'
                    ]
                )
            )
            if _default_content_type is not None:
                _header_params['Content-Type'] = _default_content_type

        # authentication setting
        _auth_settings: List[str] = [
            'bearerAuth'
        ]

        return self.api_client.param_serialize(
            method='POST',
            resource_path='/v1/ops/ai/correlate',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def ai_investigate(
        self,
        investigate_request: Annotated[InvestigateRequest, Field(description="Investigation request. Required fields: - **indicator**: The IP, domain, or hash to investigate - **indicatorType**: Must be \"ip\", \"domain\", or \"hash\"  Optional fields: - **depth**: Investigation depth (\"quick\", \"standard\", \"comprehensive\"). Default: \"standard\" - **context**: Object with optional fields: hypothesis (string), relatedIndicators (array), timeRange (string) ")],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> InvestigateResult:
        """AI Threat Investigation (Asynchronous)

        <p>Initiates a comprehensive AI-powered threat investigation for an indicator. Uses large language models to analyze threat intelligence, generate insights, and provide actionable recommendations.</p> <h4>Investigation Output:</h4> <ul>     <li><b>Verdict:</b> Threat assessment with confidence score</li>     <li><b>Timeline:</b> Activity timeline reconstruction</li>     <li><b>Analysis:</b> Detailed findings from multiple data sources</li>     <li><b>Related Indicators:</b> Discovered related infrastructure</li>     <li><b>Recommendations:</b> Suggested response actions</li> </ul> <h4>Performance:</h4> <p>LLM-based analysis. Expected completion: 30-180 seconds depending on complexity.</p> 

        :param investigate_request: Investigation request. Required fields: - **indicator**: The IP, domain, or hash to investigate - **indicatorType**: Must be \"ip\", \"domain\", or \"hash\"  Optional fields: - **depth**: Investigation depth (\"quick\", \"standard\", \"comprehensive\"). Default: \"standard\" - **context**: Object with optional fields: hypothesis (string), relatedIndicators (array), timeRange (string)  (required)
        :type investigate_request: InvestigateRequest
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._ai_investigate_serialize(
            investigate_request=investigate_request,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '202': "JobResponse",
            '200': "InvestigateResult",
            '400': "ErrorResponse",
            '401': "ErrorResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def ai_investigate_with_http_info(
        self,
        investigate_request: Annotated[InvestigateRequest, Field(description="Investigation request. Required fields: - **indicator**: The IP, domain, or hash to investigate - **indicatorType**: Must be \"ip\", \"domain\", or \"hash\"  Optional fields: - **depth**: Investigation depth (\"quick\", \"standard\", \"comprehensive\"). Default: \"standard\" - **context**: Object with optional fields: hypothesis (string), relatedIndicators (array), timeRange (string) ")],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[InvestigateResult]:
        """AI Threat Investigation (Asynchronous)

        <p>Initiates a comprehensive AI-powered threat investigation for an indicator. Uses large language models to analyze threat intelligence, generate insights, and provide actionable recommendations.</p> <h4>Investigation Output:</h4> <ul>     <li><b>Verdict:</b> Threat assessment with confidence score</li>     <li><b>Timeline:</b> Activity timeline reconstruction</li>     <li><b>Analysis:</b> Detailed findings from multiple data sources</li>     <li><b>Related Indicators:</b> Discovered related infrastructure</li>     <li><b>Recommendations:</b> Suggested response actions</li> </ul> <h4>Performance:</h4> <p>LLM-based analysis. Expected completion: 30-180 seconds depending on complexity.</p> 

        :param investigate_request: Investigation request. Required fields: - **indicator**: The IP, domain, or hash to investigate - **indicatorType**: Must be \"ip\", \"domain\", or \"hash\"  Optional fields: - **depth**: Investigation depth (\"quick\", \"standard\", \"comprehensive\"). Default: \"standard\" - **context**: Object with optional fields: hypothesis (string), relatedIndicators (array), timeRange (string)  (required)
        :type investigate_request: InvestigateRequest
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._ai_investigate_serialize(
            investigate_request=investigate_request,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '202': "JobResponse",
            '200': "InvestigateResult",
            '400': "ErrorResponse",
            '401': "ErrorResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def ai_investigate_without_preload_content(
        self,
        investigate_request: Annotated[InvestigateRequest, Field(description="Investigation request. Required fields: - **indicator**: The IP, domain, or hash to investigate - **indicatorType**: Must be \"ip\", \"domain\", or \"hash\"  Optional fields: - **depth**: Investigation depth (\"quick\", \"standard\", \"comprehensive\"). Default: \"standard\" - **context**: Object with optional fields: hypothesis (string), relatedIndicators (array), timeRange (string) ")],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """AI Threat Investigation (Asynchronous)

        <p>Initiates a comprehensive AI-powered threat investigation for an indicator. Uses large language models to analyze threat intelligence, generate insights, and provide actionable recommendations.</p> <h4>Investigation Output:</h4> <ul>     <li><b>Verdict:</b> Threat assessment with confidence score</li>     <li><b>Timeline:</b> Activity timeline reconstruction</li>     <li><b>Analysis:</b> Detailed findings from multiple data sources</li>     <li><b>Related Indicators:</b> Discovered related infrastructure</li>     <li><b>Recommendations:</b> Suggested response actions</li> </ul> <h4>Performance:</h4> <p>LLM-based analysis. Expected completion: 30-180 seconds depending on complexity.</p> 

        :param investigate_request: Investigation request. Required fields: - **indicator**: The IP, domain, or hash to investigate - **indicatorType**: Must be \"ip\", \"domain\", or \"hash\"  Optional fields: - **depth**: Investigation depth (\"quick\", \"standard\", \"comprehensive\"). Default: \"standard\" - **context**: Object with optional fields: hypothesis (string), relatedIndicators (array), timeRange (string)  (required)
        :type investigate_request: InvestigateRequest
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._ai_investigate_serialize(
            investigate_request=investigate_request,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '202': "JobResponse",
            '200': "InvestigateResult",
            '400': "ErrorResponse",
            '401': "ErrorResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _ai_investigate_serialize(
        self,
        investigate_request,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        # process the query parameters
        # process the header parameters
        # process the form parameters
        # process the body parameter
        if investigate_request is not None:
            _body_params = investigate_request


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )

        # set the HTTP header `Content-Type`
        if _content_type:
            _header_params['Content-Type'] = _content_type
        else:
            _default_content_type = (
                self.api_client.select_header_content_type(
                    [
                        'application/json'
                    ]
                )
            )
            if _default_content_type is not None:
                _header_params['Content-Type'] = _default_content_type

        # authentication setting
        _auth_settings: List[str] = [
            'bearerAuth'
        ]

        return self.api_client.param_serialize(
            method='POST',
            resource_path='/v1/ops/ai/investigate',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def ai_pivot(
        self,
        pivot_request: Annotated[PivotRequest, Field(description="Pivot request")],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> PivotResult:
        """AI Infrastructure Pivot (Asynchronous)

        <p>Performs intelligent infrastructure pivoting starting from an indicator. Uses ML to identify the most relevant relationships and suggest investigation paths.</p> <h4>Pivot Strategies:</h4> <ul>     <li><b>infrastructure:</b> Shared hosting, nameservers, certificates</li>     <li><b>registration:</b> Same registrant, registration patterns</li>     <li><b>behavioral:</b> Similar traffic patterns, communication</li>     <li><b>temporal:</b> Co-occurrence within time windows</li> </ul> <h4>Response Includes:</h4> <ul>     <li>Discovered related indicators with relevance scores</li>     <li>Suggested investigation paths ranked by priority</li>     <li>Relationship graph data</li> </ul> <h4>Performance:</h4> <p>Graph traversal with ML ranking. Expected: 10-120 seconds based on depth.</p> 

        :param pivot_request: Pivot request (required)
        :type pivot_request: PivotRequest
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._ai_pivot_serialize(
            pivot_request=pivot_request,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '202': "JobResponse",
            '200': "PivotResult",
            '400': "ErrorResponse",
            '401': "ErrorResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def ai_pivot_with_http_info(
        self,
        pivot_request: Annotated[PivotRequest, Field(description="Pivot request")],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[PivotResult]:
        """AI Infrastructure Pivot (Asynchronous)

        <p>Performs intelligent infrastructure pivoting starting from an indicator. Uses ML to identify the most relevant relationships and suggest investigation paths.</p> <h4>Pivot Strategies:</h4> <ul>     <li><b>infrastructure:</b> Shared hosting, nameservers, certificates</li>     <li><b>registration:</b> Same registrant, registration patterns</li>     <li><b>behavioral:</b> Similar traffic patterns, communication</li>     <li><b>temporal:</b> Co-occurrence within time windows</li> </ul> <h4>Response Includes:</h4> <ul>     <li>Discovered related indicators with relevance scores</li>     <li>Suggested investigation paths ranked by priority</li>     <li>Relationship graph data</li> </ul> <h4>Performance:</h4> <p>Graph traversal with ML ranking. Expected: 10-120 seconds based on depth.</p> 

        :param pivot_request: Pivot request (required)
        :type pivot_request: PivotRequest
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._ai_pivot_serialize(
            pivot_request=pivot_request,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '202': "JobResponse",
            '200': "PivotResult",
            '400': "ErrorResponse",
            '401': "ErrorResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def ai_pivot_without_preload_content(
        self,
        pivot_request: Annotated[PivotRequest, Field(description="Pivot request")],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """AI Infrastructure Pivot (Asynchronous)

        <p>Performs intelligent infrastructure pivoting starting from an indicator. Uses ML to identify the most relevant relationships and suggest investigation paths.</p> <h4>Pivot Strategies:</h4> <ul>     <li><b>infrastructure:</b> Shared hosting, nameservers, certificates</li>     <li><b>registration:</b> Same registrant, registration patterns</li>     <li><b>behavioral:</b> Similar traffic patterns, communication</li>     <li><b>temporal:</b> Co-occurrence within time windows</li> </ul> <h4>Response Includes:</h4> <ul>     <li>Discovered related indicators with relevance scores</li>     <li>Suggested investigation paths ranked by priority</li>     <li>Relationship graph data</li> </ul> <h4>Performance:</h4> <p>Graph traversal with ML ranking. Expected: 10-120 seconds based on depth.</p> 

        :param pivot_request: Pivot request (required)
        :type pivot_request: PivotRequest
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._ai_pivot_serialize(
            pivot_request=pivot_request,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '202': "JobResponse",
            '200': "PivotResult",
            '400': "ErrorResponse",
            '401': "ErrorResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _ai_pivot_serialize(
        self,
        pivot_request,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        # process the query parameters
        # process the header parameters
        # process the form parameters
        # process the body parameter
        if pivot_request is not None:
            _body_params = pivot_request


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )

        # set the HTTP header `Content-Type`
        if _content_type:
            _header_params['Content-Type'] = _content_type
        else:
            _default_content_type = (
                self.api_client.select_header_content_type(
                    [
                        'application/json'
                    ]
                )
            )
            if _default_content_type is not None:
                _header_params['Content-Type'] = _default_content_type

        # authentication setting
        _auth_settings: List[str] = [
            'bearerAuth'
        ]

        return self.api_client.param_serialize(
            method='POST',
            resource_path='/v1/ops/ai/pivot',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def find_similar_cases(
        self,
        similar_cases_request: Annotated[SimilarCasesRequest, Field(description="Similar cases request")],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> SimilarCasesResult:
        """Find Similar Cases (Asynchronous)

        <p>Uses ML to find historical threat cases similar to the current investigation. Helps analysts understand attack patterns and expected outcomes.</p> <h4>Matching Criteria:</h4> <ul>     <li>Indicator overlap and relationships</li>     <li>Behavioral patterns and TTPs</li>     <li>Infrastructure characteristics</li>     <li>Attack progression similarities</li> </ul> <h4>Response Includes:</h4> <ul>     <li>Similar cases with similarity scores</li>     <li>Case outcomes and verdicts</li>     <li>Common patterns across matches</li> </ul> <h4>Performance:</h4> <p>ML similarity matching. Expected completion: 5-30 seconds.</p> 

        :param similar_cases_request: Similar cases request (required)
        :type similar_cases_request: SimilarCasesRequest
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._find_similar_cases_serialize(
            similar_cases_request=similar_cases_request,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '202': "JobResponse",
            '200': "SimilarCasesResult",
            '400': "ErrorResponse",
            '401': "ErrorResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def find_similar_cases_with_http_info(
        self,
        similar_cases_request: Annotated[SimilarCasesRequest, Field(description="Similar cases request")],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[SimilarCasesResult]:
        """Find Similar Cases (Asynchronous)

        <p>Uses ML to find historical threat cases similar to the current investigation. Helps analysts understand attack patterns and expected outcomes.</p> <h4>Matching Criteria:</h4> <ul>     <li>Indicator overlap and relationships</li>     <li>Behavioral patterns and TTPs</li>     <li>Infrastructure characteristics</li>     <li>Attack progression similarities</li> </ul> <h4>Response Includes:</h4> <ul>     <li>Similar cases with similarity scores</li>     <li>Case outcomes and verdicts</li>     <li>Common patterns across matches</li> </ul> <h4>Performance:</h4> <p>ML similarity matching. Expected completion: 5-30 seconds.</p> 

        :param similar_cases_request: Similar cases request (required)
        :type similar_cases_request: SimilarCasesRequest
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._find_similar_cases_serialize(
            similar_cases_request=similar_cases_request,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '202': "JobResponse",
            '200': "SimilarCasesResult",
            '400': "ErrorResponse",
            '401': "ErrorResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def find_similar_cases_without_preload_content(
        self,
        similar_cases_request: Annotated[SimilarCasesRequest, Field(description="Similar cases request")],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """Find Similar Cases (Asynchronous)

        <p>Uses ML to find historical threat cases similar to the current investigation. Helps analysts understand attack patterns and expected outcomes.</p> <h4>Matching Criteria:</h4> <ul>     <li>Indicator overlap and relationships</li>     <li>Behavioral patterns and TTPs</li>     <li>Infrastructure characteristics</li>     <li>Attack progression similarities</li> </ul> <h4>Response Includes:</h4> <ul>     <li>Similar cases with similarity scores</li>     <li>Case outcomes and verdicts</li>     <li>Common patterns across matches</li> </ul> <h4>Performance:</h4> <p>ML similarity matching. Expected completion: 5-30 seconds.</p> 

        :param similar_cases_request: Similar cases request (required)
        :type similar_cases_request: SimilarCasesRequest
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._find_similar_cases_serialize(
            similar_cases_request=similar_cases_request,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '202': "JobResponse",
            '200': "SimilarCasesResult",
            '400': "ErrorResponse",
            '401': "ErrorResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _find_similar_cases_serialize(
        self,
        similar_cases_request,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        # process the query parameters
        # process the header parameters
        # process the form parameters
        # process the body parameter
        if similar_cases_request is not None:
            _body_params = similar_cases_request


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )

        # set the HTTP header `Content-Type`
        if _content_type:
            _header_params['Content-Type'] = _content_type
        else:
            _default_content_type = (
                self.api_client.select_header_content_type(
                    [
                        'application/json'
                    ]
                )
            )
            if _default_content_type is not None:
                _header_params['Content-Type'] = _default_content_type

        # authentication setting
        _auth_settings: List[str] = [
            'bearerAuth'
        ]

        return self.api_client.param_serialize(
            method='POST',
            resource_path='/v1/ops/ai/similar-cases',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def get_industry_benchmark(
        self,
        industry: Annotated[StrictStr, Field(description="Industry vertical code")],
        size: Annotated[Optional[StrictStr], Field(description="Organization size filter. Compares against organizations of similar size.")] = None,
        region: Annotated[Optional[StrictStr], Field(description="Geographic region filter. Compares against organizations in the same region.")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> BenchmarkResponse:
        """Get Industry Security Benchmark (Synchronous)

        <p>Returns anonymized, aggregated security metrics for your industry vertical. Compare your security posture against peers.</p> <h4>Available Industries:</h4> <ul>     <li>financial_services, healthcare, technology, retail, manufacturing</li>     <li>energy, telecommunications, government, education, media</li> </ul> <h4>Metrics Included:</h4> <ul>     <li><b>Risk Scores:</b> Average risk score, percentiles (25th, 50th, 75th, 90th)</li>     <li><b>Response Metrics:</b> Mean time to detect (MTTD), mean time to respond (MTTR)</li>     <li><b>Detection Metrics:</b> Detection rate, false positive rate</li>     <li><b>Threat Profile:</b> Top threats, common attack vectors, targeted assets</li>     <li><b>Trends:</b> 30-day risk trend direction and change percentage</li> </ul> <h4>Performance:</h4> <p>Pre-aggregated data. Response time typically under 500ms with 1-hour cache.</p> 

        :param industry: Industry vertical code (required)
        :type industry: str
        :param size: Organization size filter. Compares against organizations of similar size.
        :type size: str
        :param region: Geographic region filter. Compares against organizations in the same region.
        :type region: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._get_industry_benchmark_serialize(
            industry=industry,
            size=size,
            region=region,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "BenchmarkResponse",
            '400': "ErrorResponse",
            '401': "ErrorResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def get_industry_benchmark_with_http_info(
        self,
        industry: Annotated[StrictStr, Field(description="Industry vertical code")],
        size: Annotated[Optional[StrictStr], Field(description="Organization size filter. Compares against organizations of similar size.")] = None,
        region: Annotated[Optional[StrictStr], Field(description="Geographic region filter. Compares against organizations in the same region.")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[BenchmarkResponse]:
        """Get Industry Security Benchmark (Synchronous)

        <p>Returns anonymized, aggregated security metrics for your industry vertical. Compare your security posture against peers.</p> <h4>Available Industries:</h4> <ul>     <li>financial_services, healthcare, technology, retail, manufacturing</li>     <li>energy, telecommunications, government, education, media</li> </ul> <h4>Metrics Included:</h4> <ul>     <li><b>Risk Scores:</b> Average risk score, percentiles (25th, 50th, 75th, 90th)</li>     <li><b>Response Metrics:</b> Mean time to detect (MTTD), mean time to respond (MTTR)</li>     <li><b>Detection Metrics:</b> Detection rate, false positive rate</li>     <li><b>Threat Profile:</b> Top threats, common attack vectors, targeted assets</li>     <li><b>Trends:</b> 30-day risk trend direction and change percentage</li> </ul> <h4>Performance:</h4> <p>Pre-aggregated data. Response time typically under 500ms with 1-hour cache.</p> 

        :param industry: Industry vertical code (required)
        :type industry: str
        :param size: Organization size filter. Compares against organizations of similar size.
        :type size: str
        :param region: Geographic region filter. Compares against organizations in the same region.
        :type region: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._get_industry_benchmark_serialize(
            industry=industry,
            size=size,
            region=region,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "BenchmarkResponse",
            '400': "ErrorResponse",
            '401': "ErrorResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def get_industry_benchmark_without_preload_content(
        self,
        industry: Annotated[StrictStr, Field(description="Industry vertical code")],
        size: Annotated[Optional[StrictStr], Field(description="Organization size filter. Compares against organizations of similar size.")] = None,
        region: Annotated[Optional[StrictStr], Field(description="Geographic region filter. Compares against organizations in the same region.")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """Get Industry Security Benchmark (Synchronous)

        <p>Returns anonymized, aggregated security metrics for your industry vertical. Compare your security posture against peers.</p> <h4>Available Industries:</h4> <ul>     <li>financial_services, healthcare, technology, retail, manufacturing</li>     <li>energy, telecommunications, government, education, media</li> </ul> <h4>Metrics Included:</h4> <ul>     <li><b>Risk Scores:</b> Average risk score, percentiles (25th, 50th, 75th, 90th)</li>     <li><b>Response Metrics:</b> Mean time to detect (MTTD), mean time to respond (MTTR)</li>     <li><b>Detection Metrics:</b> Detection rate, false positive rate</li>     <li><b>Threat Profile:</b> Top threats, common attack vectors, targeted assets</li>     <li><b>Trends:</b> 30-day risk trend direction and change percentage</li> </ul> <h4>Performance:</h4> <p>Pre-aggregated data. Response time typically under 500ms with 1-hour cache.</p> 

        :param industry: Industry vertical code (required)
        :type industry: str
        :param size: Organization size filter. Compares against organizations of similar size.
        :type size: str
        :param region: Geographic region filter. Compares against organizations in the same region.
        :type region: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._get_industry_benchmark_serialize(
            industry=industry,
            size=size,
            region=region,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "BenchmarkResponse",
            '400': "ErrorResponse",
            '401': "ErrorResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _get_industry_benchmark_serialize(
        self,
        industry,
        size,
        region,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        if industry is not None:
            _path_params['industry'] = industry
        # process the query parameters
        if size is not None:
            
            _query_params.append(('size', size))
            
        if region is not None:
            
            _query_params.append(('region', region))
            
        # process the header parameters
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )


        # authentication setting
        _auth_settings: List[str] = [
            'bearerAuth'
        ]

        return self.api_client.param_serialize(
            method='GET',
            resource_path='/v1/ops/ai/benchmark/{industry}',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )


